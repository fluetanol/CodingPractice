// 문제번호 : 1009번
// 분산처리
// 푼 시간 : 20분
// 알고리즘 분류 : 수학

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <unordered_set>
#include <unordered_map>
#pragma warning(disable : 4996)

using namespace std;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    for (int i = 0; i < t; i++)
    {
        int a, b;
        cin >> a >> b;
        int j;
        int s = a;

        for (j = 0; j < b; j++)
        {
            s = (s % 10);
            if (j == b - 1)
                break;
            s = s * a;
        }
        if (s == 0)
            s = 10;
        cout << s << endl;
    }
}

// a^b의 나머지 주기성을 구하는 문제인데
// 이 문제의 함정은 a^b의 값이 진짜 엄청나게 크다는 것
// b의 범위가 1000000, a는 100까지의 범위를 나타내므로 int,long, longlong으로도 표현이 불가능하다.
// 이를 해결하기 위해선 나머지 연산의 수학적 특징을 알면 된다... 이거 봐라

/*

    2 % 3 = 2
    4 % 3 = 1
    8 % 3 = 2
    16 % 3 = 1
    ...
    2^n % 3 = 2 -> 1 ...
    이런 주기성을 보이고,

    4 % 5 = 4
    16 % 5 = 1
    64 % 5 = 4
    256 % 5 = 1
    ...
    4^n % 5 => 4 -> 1 -> 4 -> ...
    이라는 주기성을 보인다.

    즉 주기만 찾으면 끝까지 b번 곱할것 없이 바로 답을 구할 수 있다는 것. 

    또 다른 특징으론 나머지 연산의 분배법칙이 있는데
    (a*b) % c = (a % c) * (b % c) % c
    이다. 이 식을 조금 더 응용해보면
    ((a % c) * b) % c 랑도 같음을 알 수 있는데
    증명은 
    https://www.notion.so/2597840e3a524fc6b88cac399bc436b0?pvs=4 
    이 링크를 참고하자.


    아무튼 이를 이용하면
    a^b % 10 = (a % 10)^b % 10
    이 성립한다. 그리고 이를 이용한 예를 보면

    4 % 5 = 4
    (4 * 4) % 5 = 16 % 5 = 1
    (1 * 4) % 5 = 4 % 5 = 4
    (4 * 4) % 5 = 16 % 5 = 1
    (1 * 4) % 5 = 4 % 5 = 4
    ...
    이렇게 굳이 4를 원래 수에서 계속해서 제곱하지 않아도 나머지 주기성을 확인할 수 있다.

    이 방법을 쓰면 오버플로우 문제를 방지할 수 있는데,
    앞서 말했듯 엄청 큰 수안에서는 주기성을 구하기 위해
    a를 b번 곱하는 과정에서
    진짜 조금만 곱해도 나머지 주기성을 구하기도 전에 a에 오버플로우가 발생할 수도 있다.

    하지만 위의 분배법칙을 이용하면, a를 한번 곱하기 전에
    미리 나머지에 맞춰서 값 컷팅을(threshold)할 수 있으므로
    오버플로우를 방지할 수 있다는 것.

    s = (s % 10);
    if (j == b - 1)
        break;
    s = s * a;

    이 코드가 바로 그 역할을 하고 있으며,
    s에 a를 곱하기 전에 미리 10으로 나누어 컷팅을 하여 오버플로우를 방지함과 동시에 나머지의 주기성을 구하고 있는 것이다.

    코테에서든 실제 기능개발에서든
    나머지 연산 관련 문제에선
    (a*b) % c = (a % c) * (b % c) % c
    과 관련된 잡지식을 요구할 때가 진짜 많으니 잘 알아두도록 하자.

*/
// 문제번호 : 1041
// 주사위
// 푼 시간 : 3시간
// 알고리즘 분류 : 수학, 그리디

#include <iostream>
#include <vector>
#include <cmath>
#include <string>

using namespace std;

void Minsum(int *&dice, vector<long long> &v, int depth, int sum, vector<int> choice)
{
    if (depth == 3)
        return;
    for (int i = 0; i < 6; i++)
    {
        int tempsum = sum;
        tempsum += dice[i];

        // 고른 숫자에 따른 판정
        if (choice.size() > 0)
        {
            bool iscontinue = false;
            for (int j = 0; j < choice.size(); j++)
            {
                // i가 choice에 이미 있는 숫자거나 그 반대편에 있는 숫자라면 탈락
                if (5 - choice[j] == i || choice[j] == i)
                {
                    iscontinue = true;
                    break;
                }
            }
            if (iscontinue)
                continue;
        }

        choice.push_back(i);
        // depth개를 골라서 더했을때의 가장 작은 값
        if (v[depth] > tempsum)
            v[depth] = tempsum;
        Minsum(dice, v, depth + 1, tempsum, choice);
        choice.pop_back();
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    long long n;
    cin >> n;
    int *dice = new int[6];

    for (int i = 0; i < 6; i++)
        cin >> dice[i];

    if (n == 1)
    {
        int max = -1, sum = 0;
        for (int i = 0; i < 6; i++)
        {
            sum += dice[i];
            if (max < dice[i])
                max = dice[i];
        }
        cout << sum - max;
        return 0;
    }

    else
    {
        long long sum = 0;
        vector<long long> minv{999999, 999999, 999999};
        vector<int> choice;
        Minsum(dice, minv, 0, sum, choice);
        // 완전한 안쪽 합

        long long thside = 4,
                  twside = (4 + (8 * (n - 2))),
                  onside = (pow(n - 2, 2) * 5 + (n - 2) * 4);

        sum = thside * minv[2] + twside * minv[1] + onside * minv[0];
        cout << sum;
    }
}

/*

    이 문제의 요점은 블럭들을 쌓아 올렸을떄 몇개의 면이 보이는 가에 따라 적용시킬 주사위의 면을 정하는 것이다.

    무슨 말이냐면, n>=2에 대해서

    1. 모서리에 있는 블럭의 경우 : 3개의 면이 보임

    n>=3에 대해서

    2. 모서리가 아닌 가장자리에 있는 블럭의 경우 : 2개의 면이 보임
    3. 안쪽에 있는 블럭의 경우 : 1개의 면만 보임

    그리고 한쪽면은 바닥에 놓여있다는 조건에 따라 붙는 특수한 조건

    4. 바닥면 모서리의 경우 : 2개의 면만 보임
    5. 바닥면 가장자리의 경우 : 1개의 면만 보임

    결국 3개의 면이 보이는 케이스, 2개의 면이 보이는 케이스, 1개의 면이 보이는 케이스로 나뉘게 되는데

    각 케이스에 따라 가능한 각 면의 합의 가장 작은 값을 구하면 되고, 그 동작을 하는 함수가 Minsum이다.


    - Minsum 함수 동작

    면을 고르는 것도 그냥 골라선 안되는데,
    그냥 6개의 면중 아무거나 두개, 세개를 고르는게 아니라 자기 주위에 붙어있는 면을 고르는 방식이다.

    게다가, 세 개의 면을 고를때는 귀퉁이에 있게 되는 특성상
    반드시 서로 붙어있는 면을 골라야 한다. (1직선으로 연결되어있는 형태면 안됨)

    이 문제에선 이런 특성을 이용하라는 의미에서 input형태도

    0 - 5번 평행
    1 - 4번 평행
    2 - 3번 평행

    의 형태로 전개도 위치를 알려주는데, 이는 다시 말해 내가 k번을 골랐다면 5-k번은 고를 수 없음을 의미한다.

    또한 서로 붙어 있는 면을 골라야 하므로,
    저 평행이 되는 쌍들 중에 하나를 골랐다면 다른 평행이 되는 면은 골라선 안된다.
    예를 들어 무슨 말이냐면

    1. 0번을 골랐다면 평행한 5번은 못고름
    2. 0번을 골랐으므로 0번을 다시 선택하는 것도 안됨
    3. 2번을 골랐다면 평행한 3번은 못고름
    4. 남은 건 1- 4번 평행이므로 이 중 하나를 고름
    5. 다시 말해 (0,2,1) 또는 (0,2,4)만 가능.

    이런식으로 가능한 모든 경우의 수들 중 2개의 면을 고른 경우 가장 작은 값, 3개의 면을 고른 경우 가장 작은 값, 1개의 면을 고른 경우 가장 작은 값
    모두를 구해주면 된다.
    조합해볼 배열의 길이가 커봤자 6이므로 브루트 포스를 해도 시간이 오래 걸리지 않는다.



    - 면의 갯수 수학적으로 구해보기

    이제 남은건 3개의 면이 보여지는 블럭, 2개의 면이 보여지는 블럭, 1개의 면이 보여지는 블럭의 갯수를 일반화 하는 것인데
    규칙성을 파악해서 노가다 하는 수밖에 없다.

    n=2인 경우
`   3개의 면이 4개
    2개인 면이 4개

    n=3인 경우
    3개인 면이 4개
    2개인 면이 12개 (밑바닥 4개 + 위쪽 4개 + 옆면 4개)
    1개인 면이 9개 (밑바닥 4개 + 가운데 5개)
             (3-2)^2 * 5 + (3-2)*4 = 5 + 4 = 9

    n=4인 경우
    3개인 면이 4개
    2개인 면이 4 + (4-2) * 4 + (4-2) * 4 = 4 + (4-2) * 8 = 20개
    1개인 면이 (4-2)^2 * 5 + (4-2) * 4 = 68개
             ((n-2)^2크기의 1개인 면이 5면만큼 있고, 밑바닥에 (n-2)개의 블럭이 4면을 둘러싸고 있다는 뜻)

    이에 따라 일반화 시킨다면
    3개인 면 = 4개 고정
    2개인 면 = 4 + (n-2) * 4 + (n-2) * 4 = 4 + (n-2) * 8
    1개인 면 = (n-2)^2 * 5 + (n-2) * 4

    그리고 나같은 경우 각 면의 갯수에 따른 최솟값을 벡터에 저장시켜뒀는데,
    idx = 0인경우 1개인 면의 최솟값,
    idx = 1인 경우 2개인 면의 최솟값....
    이런식이기 때문에 벡터이름이 v라면

    1개인 면의 최종 최솟값 : ((n-2)^2 * 5 + (n-2) * 4) * v[0]
    2개인 면의 최종 최솟값 : (4 + (n-2) * 8) * v[1]
    3개인 면의 최종 최솟값 : 4 * v[2]

    결국 모든 면의 최종 최솟값은
        ((n-2)^2 * 5 + (n-2) * 4) * v[0] + (4 + (n-2) * 8) * v[1] +  4 * v[2]
    이 된다.

    

    이 문제의 가장 난관은 사실 저 면의 갯수를 일반화 시키는 건데
    큐브가 눈앞에 직접 있지 않으면 머릿속으로 생각해서 일반화 해야하므로 
    공감각 상실된 사람이면 머리좀 깨질 것이다.
    그리고 이렇게 안풀고 일일히 블럭을 쌓아가면서 최솟값 구하는 방식 쓰면 상당히 느려짐 (최소 n^3)
    이렇게 수학적 특징을 빠르게 파악하는 것도 코테에서 참 중요한 문제라고 볼 수 있겠다...

*/
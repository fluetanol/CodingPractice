//문제번호 : 1003번
//피보나치함수
//푼 시간 : 1시간

#include <iostream>
#include <vector>

using namespace std;

int main(){
    int t;
    cin >> t;
    for (int i = 0; i < t; i++)
    {
        int n;
        cin >> n;
        vector<vector<int>> v(2);
        for (int i = 0; i < 2; i++){
            vector<int> v2(n+1);
            v[i] = v2;
        }

        //초항 초기화
        v[0][0] = 1;    //0은 0 그 자체로 한개
        v[1][1] = 1;    //1은 1 그 자체로 한개

        //점화식 연산, 아래 해설 참고
        for(int i=2; i<=n; i++){
            v[0][i] = v[0][i-1] + v[0][i-2];
            v[1][i] = v[1][i-1] + v[1][i-2];
        }

            //n에서의 0갯수     //n에서의 1갯수
        cout << v[0][n] << " " << v[1][n] << endl;
    }

}

//점화식 세우고 dp로 풀면 되는 쌈뽕한 문제

//점화식 특징
/*
0 그 자체는 0이 한번
1 그 자체는 1이 한번이므로

memoization memory
   0 1 ...
0  1 0
1  0 1

n = 0 1 2 3 4 5 6 7  8  9  10 ...
    0 1 1 2 3 5 8 13 21 34 55 ...


n= 2는 0한번 1한번이므로,

f(2,0) = f(1,0) + f(0,0)
f(2,1) = f(1,1) + f(0,1)

   0 1 2
0  1 0 1
1  0 1 1

n = 3은 2한번 1한번인데,
2의 0, 1갯수는 앞서서 기록을 해뒀으니 메모한 값을 재사용하면 된다.

f(3,0) = f(2,0) + f(1,0)
f(3,1) = f(2,1) + f(1,1)

   0 1 2 3
0  1 0 1 1
1  0 1 1 2

n = 4라면 3한번 2한번
3의 0의 갯수는 1, 2의 0의 갯수는 1, 3의 1의 갯수는 2, 2의 1의갯수는 1
즉,

f(4,0) = f(3,0) + f(2,0)
f(4,1) = f(3,1) + f(2,1)

   0 1 2 3 4
0  1 0 1 1 2
1  0 1 1 2 3

...


이런식으로 풀어서 일반화를 시킨다면

f(n,0) = f(n-1,0) + f(n-2,0)
f(n,1) = f(n-1,1) + f(n-2,1)

이렇게 점화식을 세울 수 있다.

이 식 그대로 세워서 0, 1의 갯수를 출력해주면 됨



















*/
#include <iostream>
#include <vector>

using namespace std;

int main(int argc, char **argv)
{
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(0);

    int n;
    cin >> n;

    vector<int> input(n);
    for (int i = 0; i < n; ++i)
    {
        cin >> input[i];
    }

    vector<int> ans;
    ans.push_back(n);

    for (int i = n - 1; i >= 1; --i)
    {
        int bigger = input[i - 1];
        int count = 0;

        // 예외 케이스 : 자기보다 큰 건 없는 경우 -> 그냥 맨 앞에 바로 넣어두면 됨
        if (bigger == 0)
        {
            ans.insert(ans.begin(), i);
            continue;
        }

        for (int j = 0; j < ans.size(); ++j)
        {
            if (ans[j] > i)
            {
                count++;
            }

            if (count == bigger)
            {
                // 마지막에 발견된 최대 지점의 위치보다 하나 더 뒤에 놔야 해서 +1함
                ans.insert(ans.begin() + j + 1, i);
                break;
            }
        }
    }

    for (int i = 0; i < ans.size(); ++i)
    {
        cout << ans[i] << " ";
    }
    cout << endl;
}


// 문제 아이디어
// 어떤 수보다 더 큰 수의 개수가 정해져 있기 때문에,
// 큰 수 부터 일단 차례대로 넣어두며 어떤 위치에 넣어야 할지 파악하는 것

/*
    가령

        4
        2 1 1 0

    이 예시를 보자. 
    
    1. 가장 큰 수는 항상 앞에 뭘 놓든 자기가 제일 크므로 0이 고정된다. 이건 모든 테케애 적용되는 규칙, 따라서 처음 순서 예측 배열에는
    가장 큰 수를 그냥 넣어두면 된다.

    2. 그 다음 큰 수인 3은 자기 앞에 큰 수가 있다고 하는데, 3보다 큰 수는 가장 큰 수인 4밖에 없으므로, 3은 4 뒤에 위치하면 될것이라는
    생각을 해볼 수 있다.

    3. 그러면 1, 2에 의해 현재 고정된 순서는
    4 ... 3
    꼴이되는 셈이다.

    4. 그 다음 큰 수인 2는 자기 앞에 큰 수가 1개가 있다고 했다.
    그런데 현재 고정된 순서에 따르면, 3뒤에 놓으면 자기 앞에 큰 수가 2개가 되므로 안되고,
    4뒤에 놓으면 자기 앞에 큰 수가 1개가 되므로 여기에 놓으면 된다는 결론이 나온다.

    이걸 파악하는 방법은 단순히 순방향 탐색을 하며, 자기보다 큰 수가 몇개 있는지 세어보는 것이다. (즉, 이건 역방향으로 굳이 탐색할 필요가 없다)
    자기보다 큰 수가 1개 발견되었다면, 바로 그 뒤에 넣어주면 규칙이 성립된다.
    4 .. 2 .. 3

    5. 마지막으로 1은 자기 앞에 큰 수가 2개 있다고 한다.
    4번의 논리대로 똑같이 해보면 4, 2 뒤에 넣으면 되므로

    4 2 1 3

    이 정답이게 된다.
*/

/*
    큰 수 부터 넣으면 순서가 정해진다는 논리의 증명

    어떤 수 k가 있다고 하자. k보다 큰 수는 k+1, k+2, ... , n 까지 총 (n-k)개가 있다.
    이 (n-k)개의 수는 모두 k보다 앞에 위치해야 한다.
    따라서 k를 넣을 때, (n-k)개의 수가 이미 다 들어가 있는 상태이므로, k보다 큰 수의 개수를 세는 것은
    단순히 순방향 탐색으로도 충분하다.

    반대로 작은 수 부터 넣는다고 생각해보자. "k보다 작은 수들은 아직 들어가 있지 않은 상태" 이므로,
    k보다 작은 수들이 들어간 이후에 k를 넣어야 한다. 따라서 역방향 탐색을 해야 한다는 결론이 나오게 된다.
    그런데 역방향 탐색은 이미 들어가 있는 수들 중에서 k보다 큰 수를 세야 하므로, 결국 순방향 탐색보다 더 복잡한 과정이 된다.

    따라서 큰 수부터 넣는 방식이 더 직관적이고 간단한 방법이다.

*/

/*
    엣지 케이스 :  자기보다 큰 수가 0 (없는) 인 경우

    자기 보다 앞에 더 큰 수가 없다는 건데, 가장 작은 수까지 0을 만족할 수 있는 유일한 방법은
    배열 맨 앞에 위치했을 때 뿐이므로, 별도의 분기처리로 바로 맨 앞에 넣어줬다.
*/
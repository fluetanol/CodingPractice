#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <unordered_set>
#include <unordered_map>
#pragma warning(disable : 4996)

using namespace std;

int main()
{

    int t;
    cin >> t;
    vector<int> v(6);
    for (int i = 0; i < t; ++i)
    {
        for (int j = 0; j < 6; ++j)
            cin >> v[j];

        float d = sqrt(pow((v[3] - v[0]), 2.0f) + pow((v[4] - v[1]), 2));
        int bigger = v[5] > v[2] ? v[5] : v[2];

        if (d == 0 && v[5] == v[2])
            cout << -1 << endl;
        else if (bigger <= d)
        {
            if (d < v[5] + v[2])
                cout << 2 << endl;
            else if (d == v[5] + v[2])
                cout << 1 << endl;
            else if (d > v[5] + v[2])
                cout << 0 << endl;
        }
        else
        {
            if (d > abs(v[5] - v[2]))
                cout << 2 << endl;
            else if (d == abs(v[5] - v[2]))
                cout << 1 << endl;
            else if (d < abs(v[5] - v[2]))
                cout << 0 << endl;
        }
    }
}

/*
    수학적 성질을 이용한 문제
    두 원의 중심 사이의 거리가 두 원의 반지름의 합과 차이를 이용하여 접점의 개수를 구하는 문제이다.

    원이 만나는 교점의 갯수는 크게 네 가지로 나뉘는데
    1. 두 점에서 만나는 경우
    2. 한 점에서 만나는 경우
    3. 안 만나는 경우 (0개)
    4. 일치하는 경우 (무한개)

    로 나뉘며,
    또 교점이 어떤 방식으로 만나는 지도 두갈래로 나뉘는데
    1. 중점을 기준으로 서로의 바깥에서 만나는 경우
    2. 중점을 기준으로 서로의 안에서 만나는 경우
    로 나뉜다.

    각각을 판정하는 방법은 원의 반지름 특성을 잘 이용해보면 알 수 있다.

    일단 원이 안쪽에 있는 지 바깥 쪽에 있는지 판단하는 방법이다.
    -> 두 원중 반지름이 더 긴 원보다 두 중점 사이의 거리가 멀면 바깥
    -> 더 가까우면 안쪽에 있음

    만약 원1의 중점을 (x1,y1), 반지름을 r1이라 하고
    원2의 중점을 (x2,y2), 반지름을 r2라 하며, 이 중 r1이 더 길다고 하자.
    두 중점의 거리 d = sqrt((x1-x2)^2 + (y1-y2)^2) 인데
    이때 r1 >= d면 원2는 원1의 안에 있다. 반대로 r1< d면 원2는 원1의 바깥에 있다. (등호는 어디에 붙든 상관 없음)

    이번엔 안쪽, 바깥쪽에 따라 몇개의 점에서 만나는 지 확인해보자

    바깥쪽
    1. 두 점에서 만나는 경우
    -> d < r1+r2                (두 반지름의 합보다 중점 사이의 거리가 더 좁아서 두 점에서 만남)
    2. 한 점에서 만나는 경우
    -> d == r1+r2               (두 반지름의 합 = 두 중점 사이의 거리)
    3. 안 만나는 경우
    -> d > r1+r2                (두 반지름의 합보다 중점 사이의 거리가 더 커서 안 만남)

    안쪽
    1. 두 점에서 만나는 경우
    -> r1-r2 < d                
    2. 한 점에서 만나는 경우
    -> r1-r2 == d               
    3. 안 만나는 경우
    -> r1-r2 > d

    (사실 직접 그림을 그려보면서 확인해보는게 이해하기 편하니 더 자세한 설명은 생략하겠음)

    위의 모든 케이스를 if문으로 일일히 나타내면 된다...
    
    다만, 이 문제는 두 원이 일치하는 경우를 따로 처리해주어야 한다.
    두 원이 일치하는 경우는 그냥 반지름과 중점의 위치까지 같다는 소리여서
    d == 0 && r1 == r2 인 경우를 따로 처리해줘야 한다.

    아무튼 조건문을 많이 써야하는 문제였다.
    백준 알고리즘 분류에도 "많은 조건 분기" 라고 써져있음
    때론 하드코딩이 보기 좋은 답일 때도 있는 법이다.
*/
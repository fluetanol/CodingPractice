#include <iostream>
#include <climits>

using namespace std;

// 1. 블럭을 제거하고 인벤에 넣기 -> 2초
// 2. 블럭을 하나 꺼내서 가장 위에 놓기 -> 1초
// n * m, 현 블록 개수

// 내가 할 수 있는 동작
//  1. 블록을 제거하기
//  2. 있는 블록을 놓기 (단 0~255개까지)

int arr[500][500];

int main(int argc, char **argv)
{
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(0);

    int n, m, b;
    int min_second = 0;
    int max_h = 0;
    cin >> n >> m >> b;

    int min = 999, max = 0;

    for (int i = 0; i < n; ++i)
    {
        for (int j = 0; j < m; ++j)
        {
            cin >> arr[i][j];

            if (min > arr[i][j])
                min = arr[i][j];
            if (max < arr[i][j])
                max = arr[i][j];
        }
    }

    // 이미 평지인 케이스
    if (min == max)
        cout << min_second << " " << min;
    else
    {
        min_second = INT_MAX;
        max_h = min;

        for (int k = min; k <= max; ++k)
        {
            int inven_count = b;
            int req_count = 0;
            int temp_second = 0;

            // 기준 높이보다 높거나 낮은게 얼마나 있는지, 그리고 얼마의 블럭을 뺴고 쌓아야 하는지 알아보기
            for (int i = 0; i < n; ++i)
            {
                for (int j = 0; j < m; ++j)
                {
                    if (arr[i][j] < k)
                    {
                        req_count += (k - arr[i][j]);
                    }
                    else if (arr[i][j] > k)
                    {
                        inven_count += (arr[i][j] - k);
                    }
                }
            }

            // 인벤에 가져올 수 있는 최대 블럭 수보다 필요한게 더 많으면 불가능한 케이스
            if (inven_count < req_count)
            {
                continue;
            }
            // 가능하다면 몇초인지 추정 가능 (쌓는 케이스의 시간 소모 + 캐내는 케이스의 시간 소모)
            else
            {
                temp_second += req_count + (inven_count - b) * 2;

                // 최소시간이 같으면 더 큰 높이를 반환해야한다.
                if (min_second >= temp_second)
                {
                    min_second = temp_second;
                    max_h = k;
                }
            }
        }

        cout << min_second << " " << max_h;
    }
}

/*
     아이디어 : 
     최소 최대 사이의 모든 높이에 대해 브루트포스하여 몇초가 나오는지 체크하고, 그 중 최소값인 걸 고르면 되지 않을까???

     이러한 발상이 나온 이유
     1. 높이는 어차피 최소 최대 지형 사이에서만 가능
     2. 어떤 높이에서 최소시간에, 또 같은 최소시간에서도 최대의 높이를 구할 수 있을지 알기가 어렵다
     3. 그런데 높이 하나를 정해두고, 그 높이로 평탄화 하려면 얼마나 걸리느냐 에 대한 논제는 명확한 답을 구할 수 있다.
     -> 따라서 모든 높이에 대해 얼마의 시간이 나오는 지 구하고, 이들을 비교하여 가장 작은 시간 + 최대 높이를 구한다.

     이렇듯 꼭 모든 케이스를 다 구해봐야 하는 거 같은 막막한 느낌이 들 때, 
     1. "명확히 해결 가능한 소문제가 무엇인가?"
     2. "그래서 그 소문제로 다른 소문제의 답과 비교가 가능한가" 를 생각해보자

     물론 이건 실버문제라 이런 무식한 방법이 먹힌거고 좀만 높아지면 최적화도 고민해야함


    가령

    4
    0 4 4 4
    4 4 4 4
    4 4 4 8

    의 경우, 평탄화 가능 범위는 0~8 (추정)

    가령 1의 경우

    더 낮은 높이 -> 인벤에서 최대한 빼온 뒤, 빼온 만큼 1초 증가
    더 높은 높이 -> 제거 한 뒤, 제거한 만큼, 2초 증가

    그리고 매우 정확한 측정을 위해, 당연히 최대 가능한 갯수의 블럭을 인벤에 짱박아두는 게 더 의미 있는바
    더 높은 높이의 블럭들을 전부 제거한 뒤, 낮은 블럭들에 쌓는 방식으로...

    이러면 하나의 높이에 대해 걸리는 시간은
    (N * M) * 2로, O(n^2)이며
    어차피 높이의 범위가 커봤자 0~255이기 때문에 ㄱㅊ을듯
    전체 시간 복잡도는 O(256 * n^2) = O(n^2) 으로 귀결됨



    엣지 케이스 
    1. 이미 평탄화가 되어있는 경우 (이 경우 min == max)
    2. 인벤토리에 블럭이 부족해서 평탄화가 불가능 한 경우
     이건 목표 높이보다 높은 블럭들까지 전부 가져와도 낮은 높이를 채우지 못하는 경우이므로 무시하고 넘어간다.
*/
// 문제번호 : 1092
// 배
// 푼 시간 : 1시간
// 알고리즘 분류 : 그리디, 정렬

#include <iostream>
#include <vector>
#include <deque>
#pragma warning(disable : 4996)

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int n, k;
    cin >> n;
    deque<int> cranes(n);
    deque<int> idxs(n);
    for (int i = 0; i < n; i++)
    {
        cin >> cranes[i];
        idxs[i] = cranes[i];
    }

    vector<int> box(1000001);
    cin >> k;
    for (int i = 0; i < k; i++)
    {
        int t;
        cin >> t;
        box[t]++;
    }

    int count = 0;
    int boxcount = k;
    while (cranes.size() > 0 && k > 0)
    {
        int cranesize = cranes.size();

        for (int i = 0; i < cranesize; i++)
        {
            int crane = cranes.back();
            cranes.pop_back();

            int idx = idxs.back();
            idxs.pop_back();

            while (true)
            {
                if (idx < 0)
                    break;
                else if (box[idx] > 0)
                {
                    box[idx]--;
                    cranes.push_front(crane);
                    idxs.push_front(idx);
                    k--;
                    break;
                }
                else
                    idx--;
            }
        }

        count++;
    }

    if (k == 0)
        cout << count;
    else if (k > 0)
        cout << -1;
}


// 자기가 들 수 있는 최대 무게와 격차가 가장 적은 무게부터 들어올린다는 그리디한 발상으로 푸는 문제
// 다행히도 완전탐색으로 풀 필요는 없는 문제였다. 그러니까 상자의 갯수 인풋 최대가 10000인거지...

// 우선 최대한 무거운 상자부터 가벼운 상자 순서로 정렬을 해야하는데, 이를 위해 나는 카운트 정렬을 사용했다.

// 그리고 만약 현재 크레인이 들 수 있는 최대 무게가 15라면
// 리스트를 가장 높은 순서에서 낮은 순서로 볼 필요없이 15번지부터 0번지까지 차례대로 확인하면 된다.
// 만약 0번지까지 확인했는데 더 이상 확인할 상자가 없다면 그 크레인은 더이상 상자를 옮길 수 없으므로 데큐에서 제외시킨다.

// 예를 들어 13 15 10이라고 하고, 상자는 11 14 12 9 8 11 이라고 하면

//1회전
//13 -> 12
//15 -> 14
//10 -> 11
//남은 상자 : 9 8 11
//2회전
//13 -> 11
//15 -> 9
//10 -> 8

//이 후 더이상 남은 상자가 없으므로 종료, 정답은 2이다.
//참고로 모든 상자를 옮길 수 없는 유일한 케이스는 가장 무거운 짐을 들어올릴 수 있는 크레인의 무게보다 더 무거운 상자가
//단 하나라도 있는 경우이다.


/*
여담 : 사실 카운트 정렬은 이 알고리즘에선 매우 빠르다.최대 가능 인풋이 1000000인데
요즘 cpu 클럭수를 생각하면 백만의 반복은 순식간에 지나가기 때문

의외로 위 방식은 40ms로 통과하게 되었는데
사실 가장 큰 이유는 카운트 정렬로 인해 최악의 경우 1000000번지부터 아래로 쭉 내려가야 한다는 불필요한 오버헤드와
push_back, push_front로 인한 메모리 복사가 아닐까 싶다.


*/


//다른 버전

#include <cstdio>
#include <algorithm>
using namespace std;

int N, M, limits[50], nearest[50];

int main()
{
    scanf("%d", &N);
    for (int i = 0; i < N; i++)
    {
        scanf("%d", &limits[i]);
    }
    sort(limits, limits + N);

    scanf("%d", &M);
    for (int i = 0; i < M; i++)
    {
        int cargo;
        scanf("%d", &cargo);
        int foo = lower_bound(limits, limits + N, cargo) - limits;
        if (foo == N)
        {
            puts("-1");
            return 0;
        }
        ++nearest[foo];
    }

    int l = nearest[N - 1], r = M, m;
    while (l < r)
    {
        m = (l + r) / 2;
        int i, adv;
        for (i = N, adv = 0; i--;)
        {
            if (nearest[i] - adv > m) break;
            adv = m - (nearest[i] - adv);
        }

        if (i != -1) l = m + 1;
        else if (adv == 0)
        {
            r = m;
            break;
        }
        else
            r = m;
    }
    printf("%d", r);
    return 0;
}

//이해하는데 상당히 까다로운 방식으로, 이분탐색+그리디를 이용한 방법이다.

//로직의 이해는 이렇다.

/*
    N = 크레인 갯수
    M = 박스 개수
    limits = 크레인이 들 수 있는 최대 무게
    nearest = 어떤 박스의 무게를 들 수 있는 최소 크레인이 들어야 할 박스의 갯수

    ex) 만약 limits = 10 15 20 이고 박스는 8 9 11 12 17 18이라면
    최대 10의 무게를 드는 크레인 = 8 , 9 들 수 있음
    최대 15의 무게를 드는 크레인 = 11, 12 들 수 있음
    최대 20의 무게를 드는 크레인 = 17, 18 들 수 있음

    따라서 nearest = [2,2,2]가 된다.


    이제부터 이분탐색을 하는데, 무엇을 기준으로 이분탐색을 하느냐?
    바로 이 크레인들이 "몇 분 안에" 모든 박스를 옮길 수 있는지를 이분 탐색 해버린다.

    이분탐색이 가능하려면 일단 탐색이 가능한 구간이 주어져야 하는데,

    상황을 보면 가장 무거운 무게를 드는 크레인을 기준으로, 더 적은 무게를 드는 크레인들이 전부 최대한 들 수 있는 모든 짐을 들어버린다면
    그 상황이 가장 큰 크레인이 짐을 가장 적게 들게 되는 상황이 될 것이다.
    반대로 더 적은 무게를 드는 크레인이 하나도 들지 않고 가장 큰 무게를 드는 크레인에게 짬을 때리면
    진짜 짐의 갯수만큼 그 크레인이 분당 하나씩 옮겨야 하기 때문에 (문제 조건에 따라) 이 경우가 가장 최악의 케이스가 될 것이다.

    위 코드의  int l = nearest[N - 1], r = M. 가 그것을 나타내고 있다.
    즉, 우리가 원하는 시간은 l< x < r사이에 반드시 존재한다는 것.

    이제 이분탐색을 진행해보자.
    당연히 중간값부터 찾아봐야 하므로

        m = (l + r) / 2;

    로 우리가 구하고자하는 시간 m을 추정해준다.
    이제 이 m시간이 "짐을 옮기기에 최소의 시간"이 맞는지 검증을 해주면 된다.

    검증은 예를들어 다음과 같이 해주면 된다.

    ex) nearest = [4,1,0]이면 N = 3, M = 5
    m = 2(0+5)/2 = 2(int 캐스팅)
    이제 이 추정 시간 m이 각 크레인에게 할당된 짐 옮기기 시간이다.


    1. 가장 큰 크레인
    가장 무거운 크레인부터 들여다보자.
    일단 무거운 크레인일 수록 자기보다 아래에 있는 크레인이 들어야 할 짐을 "무조건" 들 수 있다는 보장이 있다.

    nearest[N-1]의 정보에 따르면 가장 무거운 크레인은 자기가 필수로 들어야 하는 짐이 0개이다.
    즉, 남은 m시간 2개의 짐을 자기보다 아래 크레인들의 짐을 들 수 있다는 것이다.

    adv = m - (nearest[i] - adv);

    즉, 이 adv는 이전 더 큰 크레인이 여전히 들어줄 수 있는 짐의 갯수를 뜻하게 된다.

    (전체 추정 시간) - (그 크레인이 필수로 들어야 하는 짐의 갯수 - 이전 크레인이 들어줄 수 있는 짐의 갯수)
    2 - (0 - 0) = 2


    2. 두번째로 큰 크레인
    그 다음 크기의 크레인은 자신이 필수적으로 들어야 하는 짐이 1개이다. (nearest[N-2] = 1)
    그런데 이 1개의 짐은 adv에도 기록되어있듯, 이전 더 큰 크레인이 최대 2개의 짐을 들어 줄 수 있는 상태이기 때문에
    그 1개의 짐은 이미 더 큰 크레인이 가져간 상태라고 보면 된다.

    그러고도 여전히 가장 큰 크레인이 들 수 있는 짐의 갯수는 2-1 =1 로 아직 한개가 더 남아있다.
    그리고 여전히 두번째로 큰 크레인은 2시간 내에 2개의 짐을 추가로 옮겨줄 수 있는 여력이 남아있다.

    즉 adv = 2 + 1 = 3이다.
    (2 - (1 - 2)) = 3

    이는 그 다음 크레인이 부담을 덜 수 있는 짐의 갯수가 무려 3개라는 것이다.


    3. 가장 작은 크레인
    가장 작은 크레인은 자신이 필수로 들어야 하는 짐이 4개이다. (nearest[N-3] = 4)
    이전 크레인들이 들어 줄 수 있는 잉여인력 adv가 3이기 때문에 4- 3 = 1

    최종적으로 이 크레인이 옮길 박스의 갯수는 1개인데,
    남은 1개는 주어진 추정 시간 2시간 중 1시간내에 옮기고도 1시간이 남는 시간이다.

    다시 말해, adv가 1이 남는다는 것.

    ------------------------------------

    그럼 모든 반복이 끝나고 adv상태를 보며 m값을 평가해보자.

    1. adv= 0 으로 나누어 떨어진다면?
    그건 딱 그 추정시간 m안에 모든 크레인이 잉여인력 없이 타이트하게 모든 짐을 옮길 수 있다는 뜻이므로, 최적의 시간이 맞다.

    2. adv가 1보다 같거나 큰 상태라면?
    위의 예시 처럼 1보다 같거나 크다는 건 m시간을 쓰고도 잉여인력이 남았다는 상태
    여전히 "최소 m이 존재 할지도 모르는" 상태라는 것이며, 그렇다고 adv>=1인 m이 정답이 꼭 아니라는 법도 없다.
    즉, 만약 adv = 0인 케이스가 없다면 지금까지 나온 adv중 adv >= 1이 되는 가장 작은 m이 정답이 된다.

    3. 반복문을 끝까지 못 돌고 해당 m시간 내에는 도저히 모든 짐을 못옮기는 경우

      if (nearest[i] - adv > m) break;
      이 케이스가 그 케이스인데, 현재 자신이 꼭 들어야 하는 짐에서, 이전 크레인들이 들어 줄 수있는 짐을 뺀 나머지 짐들을
      m시간 내에 못 옮긴다면, 당연히 이는 불가능한 케이스이다.
 
     이런 경우 m을 너무 타이트하게 잡았다는 뜻이므로, 더 널럴한 m을 잡아주면 된다.


    즉, 이 이분탐색을 요약하면
    1. 가장 무거운 크레인부터 작은 크레인 순서로 주어진 추정 시간 m내에 물건을 옮길 수 있는 지 검증
        - 검증을 할때, 상대적으로 더 무거운 크레인이 m시간내에 들고도 남은 잉여 인력을 더 작은 크레인이 들 짐을 들수 있도록 계산 (adv)

    2. 만약 m시간 내에 모든 짐을 들 수 있는데 들고도 잉여 인력이 있는 경우 -> 더 나은 m이 존재할 가능성을 염두해두고 m을 낮춰보기

    3. 만약 m시간 내에 모든 짐을 들 수 없는 경우 -> 추정치 m을 더 높혀서 시간을 확보해주기

    4. 만약 m시간내에 모든 짐을 들고 잉여인력도 없이 타이트 하게 맞아 떨어진 경우 -> 무조건 정답

    5. 만약 타이트하게 맞아 떨어진 경우는 없지만, 그래도 m시간내에 모든 짐을 들 수 있는 케이스가 있는 경우 -> 그 중 가장 작은 m이 정답

    이런식으로 이분탐색을 진행하면 된다.

    위의 소팅작업 nlogn을 제외하면 시간복잡도는 이분 탐색으로 인해 O(nlogm)으로 개빠름

    인터넷에 있는 다른 모든 답들과 비교하면서 이렇게 푸는 방식은 이게 유일해보였었다.
    해설도 없고 그냥 백준에 있는 제출 풀이 중 하나였어서 코드 해석이 까다로웠음.
    속도는 0ms
*/  

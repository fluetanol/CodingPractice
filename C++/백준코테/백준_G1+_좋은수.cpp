// 문제번호 : 1060번
// 좋은수
// 푼 시간 : 이틀...
// 알고리즘 분류 : 수학, 우선순위 큐, 정렬

#include <iostream>
#include <vector>
#include <limits>
#include <algorithm>

using namespace std;

void input(vector<vector<long long>> &v, int &l, int &n)
{
    cin >> l;
    for (int i = 0; i < v.size(); i++)
        v[i].resize(l + 1);

    // 0행: 집합 S
    for (int i = 1; i < l + 1; i++)
        cin >> v[0][i];
    sort(v[0].begin(), v[0].end());

    // 1행: 좋은 수
    for (int i = 0; i < l + 1; i++)
        v[1][i] = v[0][i];

    // 2행: 좋은 구간의 수 (0으로 초기화)

    // 3행: 다음 숫자 간의 간격
    // 4행: 다음 좋은 구간의 합
    for (int i = 0; i < l; i++)
    {
        v[3][i] = v[0][i + 1] - v[0][i] - 1;
        v[4][i] = v[3][i] - 1;
    }

    v[3][l] = numeric_limits<long long>::max();
    v[4][l] = numeric_limits<long long>::max();

    // 5행 플래그
    for (int i = 0; i < l + 1; i++)
    {
        v[5][i] = 1;
    }

    cin >> n;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int l, n;
    vector<vector<long long>> v(6);
    input(v, l, n);

    int count = 0;
    while (count < n)
    {
        long long min = numeric_limits<long long>::max();
        int minidx = -1;

        for (int i = 0; i < v[0].size(); i++)
        {
            if (min > v[2][i] && v[3][i] > -1)
            {
                min = v[2][i];
                minidx = i;
            }
        }

        if (minidx == -1)
            break;

        //  0보다 큰 정수인 경우 -> 정상 출력 처리
        if (v[1][minidx] > 0)
        {
            cout << v[1][minidx] << " ";
            count++;
        }

        // 더하는 상황
        if (v[5][minidx] > 0)
        {
            v[1][minidx] = v[0][minidx] + v[5][minidx];
            v[2][minidx] += v[4][minidx];
            if (v[5][minidx] > 2)
                v[2][minidx] -= (v[5][minidx] - 2);
        }

        // 빼는 상황
        else
        {
            v[1][minidx] = v[0][minidx + 1] + v[5][minidx];
            v[4][minidx]--;
            v[5][minidx]--;
        }

        v[3][minidx]--;
        v[5][minidx] *= -1;
    }

    int rest = v[0][v[0].size() - 1] + 1;
    for (int i = 0; i < n - count; i++)
    {
        cout << rest++ << " ";
    }
}

/*
    우선순위 큐가 이 정도로 무서울 수 있구나 를 느끼게 하는 문제

    일단 일반적인 진짜 우선순위 큐를 사용하는 방식보단
    리스트 안에 여러 인자를 업데이트 시키면서 우선 순위를 계산 하는 방식을 사용했다.

    리스트의 구조도

    0행 : 집합 S
    1행 : 좋은 수
    2행 : 좋은 구간의 수
    3행 : 다음 숫자 간의 간격
    4행 : 다음 좋은 구간의 합
    5행 : 플래그 및 다음 좋은 수 유도인자

    우선 좋은 수가 어떤 패턴으로 나오는지를 파악하는게 가장 급선무인데, 다음과 같은 예시를 보자.


    [1, 5] 인 경우

    1의 좋은 구간 갯수  :  1 5, 1 4, 1 3, 1 2 4개
    2의 좋은 구간 갯수  :  1 5, 1 4, 1 3, 1 2, 2 5, 2 4, 2 3 -> 4 + 3 = 7개
    3의 좋은 구간 갯수  :  1 5, 1 4, 1 3, 2 5, 2 4, 2 3, 3 5, 3 4 -> 4 + 3 + 2 - 1 = 8개
    4의 좋은 구간 갯수  :  1 4, 1 5, 2 4, 2 5, 3 4, 3 5, 4 5 -> 4 + 3 + 2 + 1 - 1 - 2 = 7개
    5의 좋은 구간 갯수  :  1 5, 2 5, 3 5, 4 5 -> 4 + 3 + 2 + 1 - 1 - 2 - 3 = 4개

    이 규칙성을 보면, 주어진 구간 [A,B]에 대하여
    양끝점 A, B는 동일한 갯수의 좋은 구간을 가지고 있고 그 사이의 숫자는 A와 B의 차이만큼 좋은 구간을 가지고 있다.
    그리고 최종적으로는 가장 가운데에 있는 수가 가장 큰 좋은 구간의 수를 갖고 있다.
    (어느 A,B를 갖다놓든 동일한 패턴을 보임.)

    또한 좋은 구간의 수는 A또는 B와 멀어질때마다 a0 = A의 좋은 구간 수,
    공차가 -1인 등차수열을 더한것과 동일한 효과가 있고
    A또는 B와의 차이가 2이상 벌어지기 시작하면 -1 -2...이런식으로 추가로 더해지는 것을 볼 수 있다.

    이 규칙을 알아챈다면

    [2,7]인 경우
    2->7->3->6->4->5가 된다는 것을 알 수 있다.


    이제 이를 바탕으로 위 리스트를 초기화하자

    0. 0,0에는 항상 0이 들어온다. (물론 문제 조건 상 실제 출력은 안할거임)
    1. 처음 들어오는 집합 S를 좋은 수로 초기화 해놓는다.
    2. 좋은 구간의 수는 0으로 초기화 한다. 어차피 S의 원소들은 좋은 구간이 없으므로.
    3. S를 정렬하고, 앞 원소와 뒷 원소간의 숫자 간격을 구해준다. 정확히 말하면 두 원소 사이에 들어있는 숫자의 갯수를 뜻한다.
    만약 S=1 5라면 2,3,4 3개가 있으므로 (5 - 1) - 1 = 3
    즉, B - A - 1로 초기화
    단, 끝 원소는 어차피 좋은 구간의 수가 무한대임이 자명하므로 그냥 자료형 MAX값으로 초기화한다.

    4. 다음 좋은 구간의 합을 미리 구해주는데, 만약 S = 1 5라면 이 사이 가장 작을 구간의 수를 가질
    2의 경우  2 4, 2 3 2개를 갖는데, 이는 1 5의 간격에서 2를 뺀것과 항상 같다. 즉, (5 - 1)-2 = 2
    즉, B - A - 2로 초기화
    단, 끝 원소는 어차피 좋은 구간의 수가 무한대임이 자명하므로 그냥 자료형 MAX값으로 초기화한다.

    5. 마지막으로 다음 좋은 수를 유도하기 위한 인자를 1로 초기화 한다. 아래에 사용을 설명하겠음


   초기화를 바탕으로 다음과 같이 연산 한다

    1. 좋은 구간의 수가 가장 작은 것을 찾는다.
    2. 좋은 수를 출력한다.(단 0보다 큰 정수인 경우만)
    3. 다음에 올 좋은 수에 대한 좋은 구간을 계산한다. 계산법은

        "현재 좋은 구간 수(2행) + 다음 좋은 구간의 합(4행)""

        그런데 만약 이미 좋은 수가 가장 가까운 S의 원소와 2이상 차이가 난다면 위에서 말한

        " A또는 B와의 차이가 2이상 벌어지기 시작하면 -1 -2...이런식으로 추가로 더해지는 것을 볼 수 있다."

        를 만족시키기 위해 -1, -2...씩 빼준다.

        이는 플래그 값으로 알아챌 수 있는데, 플래그 값으로 몇번째 큰 좋은 구간의 수인지를 파악 가능하므로,
        이 값이 절대값 2이상을 넘어가면  + (플래그값 - 2)를 좋은 구간의 수에 더해주면 된다.


    4. 다음에 올 좋은 수를 계산한다. 계산법은

        집합 S의 원소 + 플래그 값

    이게 무슨 계산인가 싶을 건데, 다음 예시를 보자
    S = 2, 7  인 경우
    2->7->3->6->4->5가 된다는 것을 알 수 있다.

    이는 즉, 2 + 1 -> 7 - 1 -> 2 + 2-> 7 - 2 -> 2 + 3 -> 7 - 3 이런식으로 계산하는 것과 같다.
    현재 인덱스와 다음 인덱스의 S를 활용해서 다음 좋은 수를 연산하는 것인데,
    이를 위해 플래그 값이 존재하는 것이며,
    플래그의 절대값은 항상 매 두번씩 연산할때 1씩 증가해나간다는 점과,
    좋은 구간의 수 또흔 매 두번의 좋은 수를 지나갈때 업데이트 된다는 점을 이용하여 조건문을 세워야 한다.
    (즉, 2 == 7, 3 == 6, 4 == 5 이기 때문)

    즉

    if(플래그가 0보다 클때) -> 좋은 수를 플래그에서 더함
    else -> 좋은 수를 다음 S의 원소에서 플래그를 뺌

    5. 플래그와 좋은 구간의 수, 간격을 업데이트 시킨다.

    사실 위에서 플래그를 더하고 뺀다고 했는데,
    굳이 그럴 필요 없이 플래그 자체에 -1을 곱해서 부호를 매번 바꿔주면 된다.
    또한 플래그 값은 매 두번마다 1씩 감소되므로, 플래그를 빼주는 타이밍에 (음수가 되는 타이밍)에 플래그의 절댓값을 1 추가시키면 된다.
    이 외에, 아까 말했듯 좋은 구간의 수는 n+(n-1)+(n-2)+... 이렇게 더해져 나가는 특성이 있는데
    이 또한 매 두번마다 일어나는 이벤트이므로, 다음 좋은 구간의 합을 1씩 빼준다.

    마지막으로 간격 또한 그냥 1 감소시키는데, 간격이 0으로 줄어들면 더 이상 해당 S원소 사이에
    구할 좋은 수가 없다는 뜻으로 사용하면 된다.



    설명이 복잡했는데 예시로 바로 들어가보자



     5 8 11의 경우

     초기화

    0 5 8 11
    0 5 8 11
    0 0 0 0
    4 2 2 무한
    3 1 1 무한
    1 1 1 1

    첫번째 주기
    0 (출력 불가)
    5 -> 8 -> 11

    이후 결과

    0 5 8 11
    1 6 9 12
    3 1 1 무한
    3 1 1 무한
    3 1 1 무한
    -1-1-1-1

    두번째 주기
    위 표에서 가장 작은 구간의 가장 작은 수는 6

    0 5 8 11
    1 7 9 12
    3 1 1 무한
    3 0 1 무한
    3 1 1 무한
    -1-1-1-1

    세번째 주기
    위 표에서 가장 작은 구간의 가장 작은 수는 7

    0 5 8 11
    1 7 9 12
    3 1 1 무한
    3 -1 0 무한  (이제 2행은 -1이 되어서 더 이상 좋은 수를 못구하므로 업데이트도, 출력도 불가능해진다.)
    3 0 1 무한
    -1-2-1-1

    네번째 주기
    위 표에서 가장 작은 구간의 가장 작은 수는 9

    0 5 8 11
    1 7 10 12
    3 1 1 무한
    3 -1 -1 무한 (이제 3행은 -1이 되어서 더 이상 좋은 수를 못구하므로 업데이트도, 출력도 불가능해진다.)
    3 0 0 무한
    -1-2-2-1


    계속 반복하면
    10-> 1 -> 4 -> 2 -> 3

    0 5 8 11
    3 7 10 12
    5 1 1 무한
    -1 -1 -1 무한 (이제 3행은 -1이 되어서 더 이상 좋은 수를 못구하므로 업데이트도, 출력도 불가능해진다.)
    0 0 0 무한
    +3-2-2-1


    그리고 무한대의 좋은 구간 수를 갖는 12, 13, 14...순으로 증가

    최종적으로
    5->8->11->6->7->9->1->4->2->3->12->13->14 ....


    특이 케이스)
    S = 2 4 6인경우
     
     2->4->6이 아니다.
     애초에 1부터 좋은 구간이 0개이므로 1부터 시작하게 되는데,
     3, 5 또한 딱 1차이나는 두 수 사이의 수라서 좋은 구간이 없다.
     즉, 1->2->3->4->5->6이 옳은 출력.

     근데 아까 말했듯
     0을 반드시 맨 앞에 넣어주기 때문에
     맨 처음에 0이 출력 될때, 1로 업데이트가 되고 더할 좋은 구간의 수도 없어서 ((2-0-2) = 0으로 초기화됨)
     
     1 2 4 6
     0 0 0 0
     과 같이 되므로
     1->2로 출력이 된다.

     2를 선택할때
     1 3 4 6
     0 0 0 0
     3을 출력하고 4을 출력하며,

     또 4를 선택할때
     1 3 5 6
     이렇게 되어서 5->6 순으로 출력하게 된다.





    상당히 생 어거지로 푼듯한 문제였고
    저 규칙성에 맞게 자료구조를 활용해서 "구현하는 것" 그 자체가 엄청나게 빡센 문제였다.
    
    보기 드문 문제는 이해 되지만 구현이 엄청 힘든 문제...

    혹시나 더 효율적인 다른 풀이 보면 여기로 갖고오겠음.
    이 문제는 예외적으로 +처리하겠음.
*/
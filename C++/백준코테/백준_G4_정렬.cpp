// 문제번호 : 1083번
// 정렬
// 푼 시간 : 2시간
// 알고리즘 분류 : 그리디, 정렬(버블소트)

#include<iostream>
#include<vector>
#include<cmath>

using namespace std;

void print(vector<int>& v) {
	for (int i = 0; i < v.size(); i++) {
		cout << v[i] << " ";
	}
}

void input(vector<int>& v, int& n, int& s) {
	cin >> n;
	v.resize(n);
	for (int i = 0; i < n; i++) 	cin >> v[i];
	cin >> s;
}


int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int n, s;
	vector<int> v;
	input(v, n, s);

	int k = 0;

	while (s > 0 && k < n-1) {
		int max = v[k];
		int maxidx = k;

		int distance = 0;
		for (int i = k+1; i < n; i++) {
			if (max < v[i] && (i - k) <= s) {
				max = v[i];
				maxidx = i;
				distance = i - k;
			}
		}
		s -= distance;
		for (int i = maxidx; i > k; i--) swap(v[i], v[i-1]);
		k++;
	}
	print(v);
}

/*
	 "소트한 결과가 사전순으로 가장 뒷서는 것을 출력한다."
	 
	 이게 무슨 말인지 알아먹는게 관건인 문제

	예를 들면
	1 2 3 4 5
	의 경우, 최대 한번까지 돌린다면
	2 1 3 4 5
	가 사전순으로 뒤에 있음을 직관적으로 알 수 있다. 
	그러나 이를 최대 두번까지 돌린다고 생각해보자. 그렇다면

	2 1 3 4 5
	에서 버블소트 하듯이
	2 3 1 4 5
	로 하는 게 나을까? 아니면

	1 2 3 4 5
	에서 3을 가장 앞으로 내뺄수 있도록

	1 3 2 4 5
	3 1 2 4 5
	로 하는 게 더 나을까?

	당연히 후자가 더 낫다.
	이 문제는 이런 케이스를 고려해서 사전순으로 가장 뒤에 서게 되는 정렬을 찾으라는 문제이다.
	즉, 사전순으로 가장 뒷선다 라 함은
	"최대 s번을 swap연산할 수 있을때 
	최대한 가장 큰 원소가 앞으로 빠져나올 수 있는 방법을 구하라는 것"이다.


	저 사전순 이라는 단어에 잘못 꽂히면 다음과 같은 케이스에 뇌정지가 올 것이다.

	1 11 100 101 12 13

	즉 잘못하면, 사전순으로 정렬할때 13 12 101 100 11 1 이 되어야 하기 때문에
	사전순으로 내림차순 하라는 뜻으로 이해 했다면 계속 헤맸을 것이다.



	아무튼 이 부분만 이해하면 그 뒤 풀이과정은 할만해지는데,

	"s번을 돌렸을 때, 최대한 정렬이 되어있는 상태로 만들려면 어떻게 해야하는가?"	
	= "가장 맨 앞 인덱스부터 s번 내로 최대한 큰 숫자를 가지고 오는 방법은?"

	예시를 생각해보자.

	1 2 3 4 5라면
	s = 1이라면, 딱 한번 바꿀수 있으므로 1보다는 큰 그 다음 인덱스의 2와 바꾸는 방법밖에 없다.

	s= 2라면, 굳이 2를 놓지 않고 3을 놔도 된다.
	여기서 우리가 원하는 인덱스 0과 3이 있는 인덱스 2와의 거리는 2
	즉, 2번의 스왑으로 그나마 가장 큰 숫자 3을 가지고 올수 있으므로
	
	1 2 3 4 5
	1 3 2 4 5
	3 1 2 4 5

	가 정답이 된다.

	이번에 s= 4라면?
	마찬가지로 0번 인덱스로부터 거리 4이내의 최대한 큰 숫자를 찾아본다.
	그러니 당연히 4번인덱스의 5를 데리고 오면 될 것이다. 즉,

	1 2 3 4 5
	1 2 3 5 4
	1 2 5 3 4
	1 5 2 3 4
	5 1 2 3 4

	가 정답이 된다.

	위의 s=4인 경우, 현재 인덱스 0에 올 수 있는 가장 큰 수가 놓여진 경우다.
	
	그럼 만약 s=5라면?
	너무 당연하게도 이번엔 위치할 인덱스를 1 증가시켜서
	남은 교환 횟수로 1번 인덱스에 올 수 있는 그나마 가장 큰 놈을 데리고 오면 된다.

	5을 0번인덱스에 데려오는 것에 4번 소모 되었으므로,
	남은 교환횟수는 1번

	즉,

	5 1 2 3 4
	5 2 1 3 4
	가 될 것이고
	s = 6이라면

	5 1 2 3 4
	5 1 3 2 4
	5 3 1 2 4
	가 될 것이다.

	이런식으로, 인덱스 k번째에 들어올 수를 
	s번을 최대한 활용하여 가장 큰 수를 데리고 오는 방법을 찾으면 되는 것이며,
	이 반복을 s번 전부 소모할때까지, 또는 전부 정렬되서 더 이상 바꿀 것도 없어질때까지
	반복하면 되는 것이다.




	...


	이 문제 푸는데에 사실 문제 이해에 (사전순으로 뒷서는 것)
	절반 이상을 할애했고
	문제를 이해한 뒤에는 진짜 30분만에 풀어버렸다

	역시 코테는...
	문제만 이해해도...
	


*/
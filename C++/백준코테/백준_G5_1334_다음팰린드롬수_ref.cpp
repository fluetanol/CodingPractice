#include <iostream>
#include <string>

using namespace std;

int main()
{
    string n, m;
    cin >> n;
    m = n;
    for (int i = 0; i < n.size() / 2; i++)
    {   
        //끝에서부터 바꾸며 대칭을 만들어본다
        n[n.size() - 1 - i] = n[i];
    }

    //만약 이게 원래 수보다 크면 그게 정답이긴 함 (그냥 최적화 로직)
    //left > right 인 케이스를 잘 풀어쓴거라고 볼 수 있다.
    if (m < n)
    {
        cout << n << endl;
    }

    
    else
    {
        //중앙값을 구해준다.
        //나머지 연산을 이용해서 엄청 영리하게 짠 모습 (짝수면 mid-1, 홀수면 mid)
        //근데 나라면 (n-0.5)/2 로 씀
        int mid = n.size() / 2 + n.size() % 2 - 1;
        int i = mid;


        //알다시피 9인 케이스가 골치 아픈 케이스긴 한데,
        //중앙으로 부터 올라가며 9를 0으로 바꿔주고 옆의 자리를 받아올림 시키는 논리이다.
        //이것도 아주 영리함 (애초에 9가 아니면 바로 넘어감)
        while (i >= 0 && n[i] == '9')
        {
            n[i] = '0';
            i--;
        }
        
        //이건.. 9로만 이루어진 케이스에 대한 예외 처리
        //99999라면 아마 100999 인 상태가 될 것. (대칭 작업은 밑에서 후처리 해줌)
        //이것도 진짜 너무 좋은 아이디어이다...
        if (i < 0)
        {
            n = "1" + n;
        }
        //그게 아니면 그냥 해당 자리수에 1 올려주기
        else
        {
            n[i] = n[i] + 1;
        }

        //대칭 맞춰주기
        for (int i = 0; i < n.size() / 2; i++)
        {
            n[n.size() - 1 - i] = n[i];
        }

        cout << n << endl;
    }

    return 0;
}
//flag로 특이 케이스 전부 처리한 나와 다르게
//이 사람은 대가리 존나 좋다는 것을 깨달음
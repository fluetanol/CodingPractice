// 문제번호 : 1074
// Z
// 푼 시간 : 1시간 10분
// 알고리즘 분류 : 분할정복, 재귀

#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    long n, r, c;
    cin >> n >> r >> c;

    long long line = pow(2, n);
    long long num = 0, startc = 0, startr = 0;
    long long sum = line * line;

    while (line > 1)
    {
        line = line / 2;
        long long divider = startr + line;
        long long dividec = startc + line;

        sum /= 4;

        if (divider > r && dividec > c)
        {
            num += sum * 0;
        }
        // 2사분면
        else if (divider > r && dividec <= c)
        {
            startc = dividec;
            num += sum * 1;
        }
        // 3사분면
        else if (divider <= r && dividec > c)
        {
            startr = divider;
            num += sum * 2;
        }
        // 4사분면
        else if (divider <= r && dividec <= c)
        {
            startr = divider;
            startc = dividec;
            num += sum * 3;
        }
    }

    cout << num << endl;
}

/*
    분할 정복 문제인데, 재귀를 쓸 필요는 없고 Top-down방식의 반복문을 통해서도 충분히 풀 수 있다.
    문제풀이의 아이디어는 간단한데,

    Z모양의 패턴을 그리면 4개씩 묶인다는 점을 이용하는 것이다.
    가령 첫 Z는 1칸짜리 4개가 모이고, 그 다음 큰 Z는 4칸짜리가(첫 Z의 크기) 4개가 모인다.
    이 네 개는 막 일직선으로 연달아 놓이는 게 아니라,
    딱 좌표평면으로 치면 X,Y축을 기준으로 4등분 되는 1사분면~ 4사분면으로 나눠지는 것과 비슷하게 느껴진다.

    나는 이 Z가 생성되는 4구역을 다음과 같이 정의하기로 했다.

        |
      1 | 2
    --------- (사분면)
      3 | 4
        |

    이 같이 정의한 이유는 Z의 움직임을 고려했기 때문이다.
    지금 저 1,2,3,4순서대로 탐색하는 것 자체가 Z 이동의 순서를 따라가는 것이기 때문이다.

    좌에서 우로, 상에서 하방향으로 인덱스가 커진다는 가정하에, 저 구분선을 기준으로 다음과 같이 생각할 수 있다.

    (구분선의 위치를 R행과 C열이라고 하면)

    1. R행보다 작고 C열보다 작은 경우   -> 1사분면
    2. R행보다 작고 C열보다 큰 경우     -> 2사분면
    3. R행보다 크고 C열보다 작은 경우   -> 3사분면
    4. R행보다 크고 C열보다 큰 경우     -> 4사분면

    이 아이디어를 그대로 이용해서 우리가 찾고자 하는 r행 c열은 몇번째에 찾는지 생각해보자.

    1. 가장 큰 Z의 크기는 2^n * 2^n를 기준으로 R행과 C열은 전체 행과 열의 중간에 위치한다.
    앞으로도 r행과 c열은 특정 행과 열 구간 사이의 중간에 위치할 것이므로

            line = line / 2;

    이런 식으로 절반씩 쪼개질 것이며,

        long long divider = startr + line;
        long long dividec = startc + line;

    다만 이런식으로 행과 열 각각의 시작 위치 구간만 좀 다르게 될 것이다.


    2. 내가 찾고자 하는 위치 r행 c열을 기준으로 위의 조건식을 그대로 세워서 사분면을 판단해준다.
    사분면에 따라서 이제 행과 열 각각의 시작 위치가 달라지는데,

    1. 1사분면 : 행과 열의 시작 위치는 그대로다.
    2. 2사분면 : 열의 시작 위치가 변한다.
    3. 3사분면 : 행의 시작 위치가 변한다.
    4. 4사분면 : 행과 열의 시작 위치가 모두 변한다.

    무슨 말인지 궁금하다면 자신이 직접 그림 그려서 쪼개보면 사분면에 따른 구간 조정을 이해를 할 것이다.


    3. 말했듯이 z는 네 개씩 묶이는 특성이 있기 때문에
    k번째 작은 Z묶음의 최댓값은 k-1번째 큰 Z묶음의 크기의 4배이다.

    전체 크기가 2^n * 2^n이라면, 이를 4등분 시킨 더 작은 Z묶음의 크기는 2^(n-1) * 2^(n-1)이다. (4로 나눈거임)

    그럼 생각해보자. 각 사분면마다 동일하게 2^(n-1) * 2^(n-1)씩 증가한다고 생각을 한다면?

    1. 1사분면의 최솟값 : 0
    2. 2사분면의 최솟값 : 2^(n-1) * 2^(n-1) * 1
    3. 3사분면의 최솟값 : 2^(n-1) * 2^(n-1) * 2
    4. 4사분면의 최솟값 : 2^(n-1) * 2^(n-1) * 3


    4. 이 1~3번을 더 이상 쪼갤 수 없을때 까지 반복한다.
    더 쉽게 말하면 위에서 말한

            line = line / 2;

    이게 1 미만으로 내려가는 경우에 종료하면 된다.


    5. 위의 사실을 바탕으로 정리해보자.

    - 어떤 위치 r행 c열이 k사분면에 위치한다면,
      0. 전체를 4등분 시켜서 사분면을 만든다. (행으로 절반, 열로 절반 쪼개면 4등분 됨)
      1. 사분면의 특성에 따라 행 또는 열의 시작 위치를 변경시켜서 탐색 범위를 1/4씩 좁힌다.
      2. 사분면의 특성에 따라 내가 찾은 사분면의 최솟값을 구해서 더해준다.
      3. 1번과 2번을 더이상 쪼갤수 없을 때 까지 반복하면 r행 c열이 몇 번째에 위치하는 지 알 수 있다.

    ex) 4*4크기에서 3행 1열을 찾는 다면
        1. 전체 4*4크기에서 2*2크기로 쪼개지면서 3행 1열은 3사분면에 위치한다. (3사분면의 시작위치는 2,2)
        2. 3사분면의 최솟값은 ((4 * 4) / 4) * 2 = 8을 더해준다.
        3. 다시 한번 2*2크기로 쪼개지면서 3행 1열은 3사분면에 위치한다. (3사분면의 시작위치는 3,1)
        4. 3사분면의 최솟값은 ((2 * 2) / 4) * 3 = 3을 더해준다.
        5. 더 이상 쪼갤 수 없으므로 8+3 = 11이다.

    이런식으로 탐색을 하면 된다.

    결국 전체 크기에서 1/4씩 쪼개가면서 작은 문제로 나누어 해결하는 방식이기 때문에 분할-정복이라고 부른 것이며,

    일반적인 재귀 풀이 방식인 가장 작은 문제까지 쪼개서 위로 올라오는 방식이 아니라
    바로 위에서 아래로 풀어나가는 방식이므로 이를 TOP-DOWN 풀이라고 부른다.

    TOP-DOWN이든 BOTTOM-UP이든 어느쪽이든 큰 차이는 없으니 문제 성질에 맞게 풀도록 하자.
    분할 정복의 개념을 이해하기 정말 좋은 문제인듯.

*/


//아래 코드는 위 코드를 바탕으로 조건문만 개선시킨 코드
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    long n, r, c;
    cin >> n >> r >> c;

    long long line = pow(2, n);
    long long num = 0, startc = 0, startr = 0;
    long long sum = line * line;

    while (line > 1)
    {
        line = line / 2;
        long long divider = startr + line;
        long long dividec = startc + line;

        sum /= 4;

        if (dividec <= c)
        {
            startc = dividec;
            num += sum * 1;
        }
        if (divider <= r)
        {
            startr = divider;
            num += sum * 2;
        }
    }
    cout << num << endl;
}

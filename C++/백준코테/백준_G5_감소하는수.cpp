// 문제번호 : 1038번
// 감소하는 수
// 푼 시간 : 1시간 30분
// 알고리즘 분류 : 백트래킹, 브루트 포스

#include <iostream>
#include <vector>

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    int count = 0;
    vector<int> v({0, 10});

    while (count < n)
    {
        v[0]++;
        for (int i = 0; i < v.size() - 1; i++)
        {
            if (v[i] < v[i + 1])
                break;
            else if (v[i] >= v[i + 1] && i < v.size() - 2)
            {
                v[i] = i;
                v[i + 1] += 1;
            }
            else if (v[i] >= v[i + 1] && i >= v.size() - 2)
            {
                v[i + 1] = i + 1;
                v[i] = i;
                v.push_back(10);
                break;
            }
        }
        if (v.size() > 11)
            break;
        count++;
    }

    if (v.size() > 11)
        cout << -1;
    else
    {
        for (int i = v.size() - 2; i >= 0; i--)
        {
            cout << v[i];
        }
    }
}

/*
    알고리즘 분류에 브루트포스라고도 하는데 0부터 규칙에 맞게 한 자리수 늘려가면서 풀어야 하니까
    맞는 말이긴 한듯

    이 문제를 풀 때 쓰이는 주 아이디어는 다음과 같다.

    1. 받아 올림
    주 아이디어는 "받아 올림" 에 있는데,
    10진법에서는 두 수의 합을 구할 때 k번째 자리가 9를 넘어가면
    k+1번째 자리는 1을 올려 받고 k번째 자리는 10을 뺀 나머지 수를 넣는다.

    대충 비슷한 느낌으로, 이 문제는 k번째 자리가 1을 받아올림 해줘야 하는 타이밍이 k+1번째 자리에 기록되어있다.
    만약 k+1번째 자리가  8이라면, k번째 자리는 8을 넘어가선 안되고, 만약 넘어가게 된다면
    k+1번쨰 자릿수에 1을 더해주고, k번째 자리는 초기화를 시켜준다.

    ex)
         75 -> 76 -> 80 -> 81 ....
         8 -> 9 -> 10 -> 20 -> 21 ...

    이렇듯 k번째 자리가 k+1번째 자리의 정보를 바탕으로 "거슬러 올라가면서" 받아올림을 할지 말지를
    결정해야 하므로 백트래킹 문제라고 볼 수 있는 것.


    2. 자릿수 초기화
    위에 말했듯이 k번째 자리는 k+1번째 자리의 수보다 무조건 작아야 하고, 만약 이보다 같거나 크면
    k+1번째 자리는 1 받아올림, k번째 자리는 초기화를 시켜줘야 한다고 했다.

    그런데 여기서 초기화는 무작정 0으로 만들어주면 안되는데 그 이유를 보자

    ex) 자릿수가 3개인 경우

        가장 큰 자릿수가 1이라면, 둘째 자리는 무조건 0밖에 올 수 없고
        셋째 자리엔 -1이 와야하지만, 이는 불가능 하다.
        즉, 가장 큰 자리는 적어도 2가 와야 둘째 자리는 1, 셋째 자리는 0으로 놓아 감소하는 수를 만들 수 있다.
        이처럼 자릿수의 위치에 따라 시작 값이 달라진다는 건데, 위 규칙에 따르면 이렇게 추정할 수 있다.

        자릿수가 n개인 경우
        n번째 자리는 n-1부터 시작
        n-1번째 자리는 n-2부터 시작...
        ...
        2번째 자리는 1부터
        1번째 자리는 0부터 시작

        이 규칙을 생각해보면 이런 생각도 할 수 있다.

        "그럼 가장 큰 감소하는 수는 9876543210이겠고, 이 이상의 감소하는 수는 존재할 수 없구나"

        이 사실을 깨달으면 왜 문제에서 "n번째 감소하는 수가 없다면 -1을 출력한다"라는 소리를 했는지 알 수 있다.


    3. 자릿수 넓히기
    만약 현재 수가 98이면 다음 감소하는 수는 뭘까?
    일단 1의 자릿수는 9보다 작아야 하는데, 현재 8이므로 더 이상 증가가 불가능하다.

    그럼 9는 받아올림을 받아서 10이 되어야 하는데,
    이는 십의 자리수가 아니라 백의 자리수로 넓혀야 한다는 소리다.
    즉, 받아 올림의 특수한 규칙이다.

    위 규칙대로면 만약 현재 n의 자릿수고, 받아 올림이 n번째 자리에서 일어난다면
    n+1번째 자리로 넘어가며 초기화 작업을 해야한다.


    4. 실제 구현
    위와 같이 자릿수 넓히기, 그리고 숫자를 더해야 한다는 부분 때문에 나는 벡터로 구현했는데
    벡터로 구현하면 string과 다르게 숫자 더하기가 오히려 편하다.vector<int>로 하면 되니까 ㅇㅇ
    string으로 하면 -'0'을 쓰거나 int 캐스팅 해야해서 코드 가독성이 거슬릴 듯
    게다가 vector는 push_back으로 확장도 편함

    그리고 무엇보다 vector를 쓰면 자릿수 넓히는 조건에 꼼수를 쓰는것도 가능하다.
    만약 현재 n자릿수라면, 일부러 n+1번째 자리를 만들어서 그 위치에 10을 넣는다.
    최상단 n 번째 자리는 9까지 도달이 가능하기 때문에, 10이 들어있는 n+1번째 자리랑 비교하면
    자연스럽게 이전처럼 대소비교를 통해 push_back을 할지 말지 결정을 할 수 있는 것이다.
    string을 쓰면 이런 방식이 힘들어진다. 10은 string으로 두 자리를 차지하기 떄문.

    즉, 최상단 자리가 9를 넘어갈때에 대한 예외 처리를 하는 복잡한 코드를 넣지 않고도
    일관성 있게 기능을 구현할 수 있기에 코드 직관성이 높아진다.

    이 설명들을 바탕으로 써본다면

    for(int i=0; i<v.size()-1; i++){
        if(v[i] < v[i+1] break;
        현재 자릿수가 여전히 다음 자릿수보다 작다면 그냥 넘어감

        else if(v[i] >= v[i+1] && i< v.size()-2)
        현재 자릿수가 다음 자릿수보다 크지만, 그 다음 자릿수가 여전히 존재한다면{
            v[i+1] ++; (받아올림)
            v[i] = i;  (초기화)
        }

        else if(v[i] >= v[i+1] && i>=v.size()-2){
          현재 자릿수가 다음 자릿수보다 크고, 그 다음 자릿수가 최상단 자릿수라면{
            v[i+1] = i+1; (받아올림)
            v[i] = i;     (초기화)
            v.push_back(10); (자릿수 확장)
            break; 
            (이건 반복문 v.size()-1번째 자리가 push_back으로 확장되기 때문에 무한루프 도는 걸 방지하기 위함임)
          }
        }
    }

    이렇게 되는듯

    처음엔 어떻게 구현할지 좀 골아팠는데

    좀 싱크빅하게 풀은듯


*/


// 큐를 활용한 풀이
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

long long find_decreasing_number(int n)
{
    if (n > 1022) // 1022번째 감소하는 수가 마지막이다.
        return -1;

    queue<long long> q;
    for (int i = 0; i < 10; i++)
        q.push(i);

    int count = -1;
    long long num;

    while (!q.empty())
    {
        num = q.front();
        q.pop();
        count++;
        if (count == n)
            return num;

        int last_digit = num % 10;
        for (int next_digit = 0; next_digit < last_digit; next_digit++)
            q.push(num * 10 + next_digit);
    }

    return -1;
}

//이 방식은 큐에서 0~9까지 먼저 순차적으로 넣고
//하나씩 큐에서 수를 뺄 때마다 
//그 수로 만들 수 있는 예상 가능한 수를 연산해서 다시 큐에 넣는다.

//여기서 예상 가능한 수는 가장 낮은 자릿수보다 작은 수를 덧붙히는 방식이다
//예를 들어보자

//0 1 2 3 4 5 6 7 8 9

//0을 뺄때 -> 0 그 자체가 가장 작음

//1을 뺄때 -> 1보다 작은 0을 붙혀서 큐에 넣음 -> 10

//2를 뺄때 




int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    cout << find_decreasing_number(n) << '\n';

    return 0;
}

//더 씽크빅 하게 푼 미친 방법

#include <stdio.h>

int main()
{
    int l, E = 9;
    long long int DP[1024] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    scanf("%d", &l);
    if (l > 1022)
    {
        printf("-1");
        return 0;
    }
    for (int i = 0; E < l; i++)
    {
        for (int j = 0; j < DP[i] % 10; j++)
            DP[++E] = DP[i] * 10 + j;
    }
    printf("%lld", DP[l]);
}

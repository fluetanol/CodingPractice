// 문제번호 : 1010번
// 다리 놓기
// 푼 시간 : 1시간
// 알고리즘 분류 : 수학, DP, 조합론

#include <iostream>
#include <vector>

using namespace std;

void input(int &n, int &m, vector<vector<int>> &v)
{
    cin >> n >> m;
    v.resize(n);
    for (int i = 0; i < n; i++)
    {
        v[i].resize(m);
    }
    for (int i = n - 1; i < m; i++)
        v[n - 1][i] = 1;
}

int main()
{
    ios::sync_with_stdio(0);
    cout.tie(0);
    cin.tie(0);

    int t;
    cin >> t;
    for (int i = 0; i < t; i++)
    {
        int n, m;
        vector<vector<int>> v;
        input(n, m, v);

        for (int i = n - 2; i >= 0; i--)
        {
            for (int j = m - 2; j >= 0; j--)
            {
                v[i][j] = v[i + 1][j + 1] + v[i][j + 1];
            }
        }

        int sum = 0;
        for (int i = 0; i < m; i++)
        {
            sum += v[0][i];
        }
        cout << sum << endl;
    }
}

// 1. DP로 풀기 (내가 푼 방법)

/*
    2차원 배열을 다음과 같이 구성하면 된다.

    행 : 서쪽의 몇번쨰 사이트까지 선택했는지
    열 : 동쪽의 몇번째 사이트를 선택했는지

    가령 서쪽 = 4, 동쪽은 7개가 있다고 해보면, 배열 크기는 4*7이 되고,

    또 가령 v[2][4]라 하면 서쪽 2에서 동쪽 4를 가리킬 때의 경우의 수라는 걸 알 수 있다.


    서쪽의 마지막 사이트를 선택했을 때는 무조건 1이라는 걸 생각해보자.
    v[3][6] = 1, v[3][5] = 1....

    물론 전부다 1은 아니고, 만약 서쪽이 4개라면, 아무리 넉넉하게 잡아도
    1 2 3을 고를 경우, 4, 5, 6, 7까지만 고를 수 있으므로,
    v[3][3], v[3][4], v[3][5], v[3][6]까지만 1로 초기화가 된다.

    이제 이를 이용해서 다음 사이트의 경우의 수를 구해보자.

    v[2][4]라면, 서쪽 3번째 사이트가 이미 동쪽 4번째 사이트를 먹었다는 것이므로,
    서쪽 4번째 사이트는 남아있는 5, 6, 7 중 하나를 선택 해야 한다.

    v[2][5]라면, 서쪽 3번째 사이트가 이미 동쪽 5번째 사이트를 먹었다는 것이므로,
    서쪽 4번째 사이트는 남아있는 6, 7 중 하나를 선택 해야 한다.

     v[2][6]라면, 서쪽 3번째 사이트가 이미 동쪽 6번째 사이트를 먹었다는 것이므로,
    서쪽 4번째 사이트는 남아있는 7 중 하나를 선택 해야 한다.

    즉, v[2][j]에서, j의 값에 따라 선택의 폭이 달라지는데,
    이는 전체 m개의 동쪽 사이트에서  j개를 뺀 만큼의 선택지가 생김을 알 수 있다.
    그런데 생각해보자, 아까와 같은 배열 구성이라면...

    0 1 2 3 4 5 6
 0
 1
 2      4 3 2 1 0
 3  0 0 0 1 1 1 1

    같은 형태가 된다는 것을 볼 수 있지 않겠는가?

    즉, v[i][j]일때, v[i+1][j+1] + v[i][j+1]의 규칙성을 띄는 걸 볼 수 있다.

    이는 당연한 논리인데, 당연히 뒤에 고를 사이트는 앞에 고른 사이트에 따라서 선택 범위가 제한이 있고,
    그 제한 범위는 만약 앞에 고를 사이트가 k인 경우, k+1~m까지의 범위를 갖기 때문이다.

    이런 규칙성은 첫번째, 두번째 사이트 모두 갖는 공통 특성이므로,
    위의 점화식을 그대로 활용해서 채워넣으면...

    0 1 2 3 4 5 6
 0 2010 4 1 0 0 0
 1 1410 6 3 1 0 0
 2  4 4 4 3 2 1 0
 3  0 0 0 1 1 1 1

    결국 0번행의 정보, 즉, 서쪽에서 처음 동쪽 사이트의 위치를 결정하는 순간에
    몇개의 하위 경우의 수가 나오는 지를 볼 수 있으므로,
    0행의 모든 값을 합쳐주면 그게 전체 경우의 수가 된다. - 라는 논리


    이 방식의 단점이라면 당연히 dp풀이기 때문에 직관성이 떨어지고, 로직이 복잡하다는 것이다.
    게다가 이 문제는 더 빨리 풀수 있는 "수학적인 풀이"가 존재한다...

*/



//2. 조합의 특성을 활용하기

// 조합은 말 그대로 "순서 상관 없이 그냥 나올 수 있는 모든 집합"을 고르는 것이다.
// 예를 들어 {2,1,3}이든 {3,1,2}든 {1,2,3}든 상관이 없이 하나로 친다는 것이다.

// 그럼 이 문제의 특성을 보자.

//우선 n개의 사이트가 있고, m개의 동쪽 사이트가 있다고 한다.
//항상 n<=m이므로 m이 더큼.

//즉, "m개의 동쪽사이트 중 n개를 고르는 문제"인데,
// 이미 문제 내에선 "교차 하는 경우"는 안된다고 했다. 다시말해서,

/*
    {1,2,3,4}는 가능하지만 {1,4,3,2}, {2,3,1,4}같은건 전부 안된다는 것.
    즉, 어차피 순열로 구할 필요가 없이, 조합으로 구하면 끝나는 문제이다.
    왜냐면 원소 구성만 같은 집합의 가짓수를 구하는 문제와 다를바 없기 때문
*/

/*
    한마디로, n, m이 주어졌을때, mCn을 구하는 문제라는 것이다...!!!
*/


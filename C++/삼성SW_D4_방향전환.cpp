// https :  swexpertacademy.com/main/solvingProblem/solvingProblem.do
// 삼성아카데미d3방향전환
// 24/05/03

#include <iostream>
#include <cmath>
using namespace std;
int m = 999;

int main(int argc, char **argv)
{
    int test_case;
    int T;
    cin >> T;
    for (test_case = 1; test_case <= T; ++test_case)
    {
        int x1, y1, x2, y2, count = 0;
        cin >> x1 >> y1 >> x2 >> y2;
        x2 += -x1;
        y2 += -y1;
        x2 = abs(x2);
        y2 = abs(y2);
        x1 = 0;
        y1 = 0;

        // x가 짝수 -> y는 홀수번째에 깎임
        // x가 홀수 -> y는 짝수번째에 깎임
        if (x2 > y2)
        {
            count = (x2 * 2 - (y2 + (x2 % 2)) % 2);
        }
        else
        {
            count = (y2 * 2 - (x2 + (y2 % 2)) % 2);
        }
        cout << "#" << test_case << " " << count << endl;
    }
    return 0; // 정상종료시 반드시 0을 리턴해야합니다.
}

//dfs는 시간초과, bfs는 (0,0)을 기준으로 (x2,y2)라고 했을때 
//O(x2*y2)정도의 시간이 걸린다. 크게 유의미한 시간은 아니임.
//그냥 큐를 인자로 보내서 풀던대로 풀면 된다. 
//다만 BFS는 구현이 조금 짜증나므로
//이번엔 수학적으로 접근해서 풀었다.

/*
...
5 6 5 6
4 3 4 5
1 2 3 6
0 1 4 5 ...

이런 특이한 규칙이 있었다. 쉽게 말하면
기본적으로 (0,0)을 기준으로 (X,Y)의 왔다갔다 최소거리는
X와 Y중 더 큰 값을 기준으로 (X가 더 크다 가정함)

X*2 가 기본적인 폼이였다.

여기에서 X와 Y의 홀짝여부에 따라서 살짝 달라지는데,
X가 홀수일때, Y도 홀수여야 X*2가 만족하고
반대로 X가 짝수일때 Y도 짝수여야 X*2를 만족했다.

그렇지 않으면 X*2-1, 이게 최단거리다. 즉,

if X%2 == Y%2 -> X*2;
else -> X*2-1;

라는 것... 참고로 위에 내가 세운 식
         count = (x2 * 2 - (y2 + (x2 % 2)) % 2);
은 더이상 중첩 if문을 쓰기 싫어 위 조건문을 하나의 식으로 나타낸
선형적인 식이다...
괜히 복잡해보이니 어지간해선 if문으로 표현하는것이 가독성에 더 좋을거라 본다.


참고로 실제 입력값은 0,0 시작점이 아닐수도 있으므로 입력값을 
이 조건에 맞게 평행 이동시키는 게 계산에 편리하며,
또한 x2,y2중 더 큰 값을 고르라 했는데, 정확히 말하면 절댓값 x2와 절댓값 y2중
더 큰 값을 고르는 것이다. (거리는 마이너스가 의미 없는 작업이기 때문)
즉, x2,y2의 평행이동 결과가 2,-4라면 그냥 처리하면 x2>y2가 되어버리므로
반드시 절댓값을 세워서 계산을 해줘야 한다.



*/

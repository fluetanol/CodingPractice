// https :  swexpertacademy.com/main/solvingProblem/solvingProblem.do
// 삼성아카데미d4순열의아름다움
// 24/05/11
// 3시간... (답지 확인함)

#include <iostream>
#include <vector>

using namespace std;

int main(int argc, char **argv)
{
    int test_case;
    int T;
    cin >> T;

    for (test_case = 1; test_case <= T; ++test_case)
    {
        long long n, a;
        cin >> n >> a;

        vector<long long> v(n + 1);
        v[0] = 1;
        for (int i = 1; i <= n; i++)
            v[i] = (v[i - 1] * i) % a;

        long long sum = 0;
        for (int k = 0; k < n; k++)
        {
            sum += (((v[n - k] * (n - k)) % a) * v[k + 1]) % a;
            sum %= a;
        }

        cout << "#" << test_case << " " << sum << endl;
    }
    return 0; // 정상종료시 반드시 0을 리턴해야합니다.
}


// https://sehun5515.tistory.com/158
// 너무너무 어려워서 답을 찾아본 문제...
// 사실상 dp문제였는데 메모이제이션할 값은 r-l = j 가 되는 경우의 수였다.

/*
이 문제의 핵심 아이디어는

1. 무엇을 메모이제이션 할 지 파악할 수 있었느냐
2. 메모시킨 값을 보고 어떤 규칙이 있는지 파악할 수 있느냐
3. 규칙을 점화식으로 만들고 이를 최대한 최적화 시킬 수 있느냐

무려 고난이도 아이디어 세개를 요구하는 문제였다
사실 보통 2번까지만 만족해도 풀리게 할 법한 문제였으나
3번까지 요구하게 되는 이유는 이 문제의 n값의 최대 범위가 무려 10만이 넘어갔기 때문이다.
잘못하면 O(N!)이 나오는 문제고, dp 배열을 2차원 배열로 풀어도 O(n^2)이 나올수도 있는 문제인데
해당 문제는 40개의 테스트케이스를 1초안에 통과하게 만들으라는 괴랄한 조건을 내걸었기 때문에
O(n^2)도 위험한 문제라고 판단했었다


1번 아이디어 -> r-l = j가 되는 경우의 수를 기록해두는 게 좋다.
예를 들어 n=3이라면 나올 수 있는 j값은 0,1,2이다 (n에서 반드시 1이상의 값을 뺴야 하므로 j=n이 불가능)

일단 크기가 n인 1차원 배열을 놓고 n-1과 n번째 간의 관계를 풀어서 dp연산하고 싶지만,
아무것도 모르는 상태에서 이렇게 하면 점화식 관계를 세우기가 어렵다..
2차원 배열로 다음과 같이 메모이제이션 해본다

arr[k][j]  =   { n=k일때, j = 0,1,2,....,k-1인 경우의 수 }


2번 아이디어
일단 우리는 다음과 같은 사실을 자명하게 얻을 수 있다

1. j = 0인 경우는 두 수가 같은 경우이므로, 같은 인덱스 쌍일 수밖에 없다

예를 들어 n=3이면 [1,2,3]일때 (1,1)(2,2)(3,3)인 경우만 가능하다는 것
순열의 갯수는 총 n!이고, 한 순열당 n개의 쌍이 존재하므로

항상 arr[k][0] = k! * k 이라는 걸 알 수 있다.

2. j= n-1인 경우는 두 쌍이 반드시 (n,1)인 경우이다.

다시 말해 한 순열당 1개의 쌍만 존재해야 하므로
항상 arr[k][k-1] = k!임을 알 수 있다

위 두 개에 맞춰서 보면 다음과 같이 표가 만들어진다

    0   1   2   3   4   5
1   1
2   4   2
3   18  8   6
4   96  ?   ?  24
...

위 표를 보면 대각선이 다음과 같은 규칙을 지님을 볼 수 있다

arr[k][j] = arr[k-1][j-1] * j

이러면 ?의 값을 다음과 같이 예측해볼수 있다.


    0   1   2   3   ...
1   1
2   4   2
3   18  8   6
4   96  36  24  24
...



3번 아이디어
위 2차원 배열을 바탕으로 규칙을 1차원형태의 점화식으로 바꿔보자

위 표에 맞춰서 n=k일때, j의 규칙을 알아내면

j = 0 -> k!*k;
j = 1 -> (k-1)! * (k-1) * 1 * 2;
j = 2 -> (k-2)! * (k-2) * 1 * 2 * 3
...
j = h -> (k-h)! * (k-h) * (h+1)!

다시 말해 n=k일때 순열의 아름다움 지수는

sum(n = 0~n-1) {(n-h)! * (n-h) * (h+1)!}

팩토리얼은 별도의 배열을 만들어서 팩토리얼 표를 만들면 되고

결국 저 sum의 경우에는 메모이제이션한 1차원 팩토리얼 표에서 값을 갖다 쓰면서
반복문에서 j=0~n-1까지 값을 추가시키고 출력하면 끝난다.
따라서 놀랍게도 성능은 O(n) (O(2n))


*/

//나머지 연산에 관한 문제
/*
알다시피 이 문제는 점화식에 팩토리얼이 껴있는데다가, n은 10만을 넘어가므로
longlong타입으로도 표현 안될 정도의 큰 수를 저장해야하는데
이 떄문인지 나머지 연산으로 값 커팅을 하도록 유도 하고 있다

문제는 어느 타이밍에 나머지 연산을 해야 하냐는 건데
왜냐면 마지막 sum에서 나머지 연산을 해버리면 이미 과도하게 큰 값으로 인한
오버플로우 된 값을 나머지 연산하게 되기 때문에 부정확한 값이 나오게 된다

내가 발견한 중간 나머지 연산 타이밍은 이렇다 (p = 나머지 연산 할 값)

1) 메모이제이션할 팩토리얼 값 나머지 연산
2) ((n-h)! * (n-h))에 대한 나머지 연산
3) {(((n-h)! * (n-h)) % p) * (h+1)!}에 대한 나머지 연산
4) 혹시 모를 상황에 대비한 최종 sum값에 대한 나머지 연산

1~3의 경우 모두 오버플로우의 위험이 존재하는 연산들이다
두 큰 수의 곱이 존재 하는 연산들이 있을 때마다 나머지 연산을 하여
계속 해서 오버플로우가 터지지 않도록 threshold를 해줄 필요가 있다...
이런 나머지 연산 타이밍까지 생각해야 하는 너무 머리아픈 문제...

*/
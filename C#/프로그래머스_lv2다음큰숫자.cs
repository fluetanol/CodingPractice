//https://school.programmers.co.kr/learn/courses/30/lessons/138476
//프로그래머스_lv2다음큰숫자
//2024.03.14
//20분

using System;

class 프로그래머스_lv2다음큰숫자
{
    public int solution(int n)
    {
        int answer = 0;
        int bit = (int)Math.Log(n, 2) + 1;
        int count = 0;
        for (int i = 0; i < bit; i++)
        if ((n & 0x1 << i) > 0) count++;
        

        n = n + 1;
        while (true)
        {
            int newcount = 0;
            bit = (int)Math.Log(n, 2) + 1;
            for (int i = 0; i < bit; i++)
            if ((n & 0x1 << i) > 0) newcount++;
            
            if (newcount == count) break;
            n++;
        }
        answer = n;

        return answer;
    }
}


//이 문제는 사실 1의 갯수를 얼마나 빠르게 구할 수 있느냐에 따라 성능이 갈린다

//위의 (n & 0x1 << i)는 잘 알려진 비트 1의 갯수 또는 위치를 구하는 식이다.
//식의 의미는 간단한데, n과 0x1에 and연산을 하며 0이 나오는지 아닌지를 확인하는 것이다.
//이때 n의 모든 비트를 확인하기 위하여 1칸씩 0x1을 밀어나간다
//즉, 반복문이 돌때마다 00...1, 00...10, 00..100 이렇게 증가하며
//1이 있는 자리에 n도 1이 있다면 그 자리만 살아남아서 0이 아닌 값이 나오고
//그 자리마저 0이라면 and를 해도 false이기 때문에 0이 나올 것이다.
//아무튼 이런 방법으로 0이 아닌 수가 나오면 count를 시켜주고
//그래서 원래 n값의 1의 갯수를 구해준다
//그 뒤로는 그냥 n을 1씩 더해가며 새로운 n에 대한 1의 갯수를 구해주면 된다.


//n이 1000000이나 나올 수 있어서 이중 반복문 쓰는 거면 n^2으로 시간초과 나는거 아니냐 생각하겠는데
//애초에 반복문으로 돌려도 되는 이유가 실제론 반복횟수가 그리 많지가 않은 문제이기 때문이다.

//1. 비트 수를 구하는 반복횟수는 대략 log(n)이고
//2. 아무리 최악의 수가 나온다고 한들 그래봤자 나보다 1비트 더 큰 숫자까지 접근하는 것임.

//그니까 가장 골치아픈 경우가 11111110... 뭐 이런 케이스라는 건데 사실 그래봤자
//1001111111같이 비트를 1 더 추가하며 max bit에 1을 키고
//나머지 비트를 오른쪽에서부터 차례대로 1로 켜놓으면 되는 규칙성이 있다.
//그리고 아무리 최악이여도 원래 수 n의 비트 갯수보다 1작은 수 만큼 반복문을 돌리면 된다는 것도 알 수 있다.
//즉, 주어진 n보다 무조건 더 적은 반복을 돌릴 수 밖에 없다는 것.

//최악의 케이스여도 O(nlog(n))임을 알 수 있다. 최상의 케이스는(O(1)), 평균 O(n)

//마지막으로 나누기, 나머지가 아닌 저런 비트연산을 쓴 방식은 하드웨어적으로도 정말 빠르다.
//위 방식은 아무리 오래걸려도 0.30ms가 나온 방식.

//https://school.programmers.co.kr/learn/courses/30/lessons/120866
//프로그래머스_lv0겹치는선분
//2024-02-25
//소요시간 40분

public class 프로그래머스_lv0겹치는선분
{
    public int solution(int[,] lines)
    {
        int answer = 0;
        int min = 999;
        int max = -999;

        for (int i = 0; i < 3; i++)
        {
            if (min > lines[i, 0]) min = lines[i, 0];
            if (max < lines[i, 1]) max = lines[i, 1];
        }
        int offset = 0 - min;
        int[,] check = new int[max - min + 1, 3];
        for (int i = 0; i < 3; i++)
        {
            int start = lines[i, 0] + offset;
            int end = lines[i, 1] + offset;
            for (int j = start; j < end; j++) check[j, i]++;
        }

        for (int i = 0; i < (max - min + 1); i++)
        {
            if (check[i, 0] + check[i, 1] + check[i, 2] > 1) answer += 1;
        }

        return answer;
    }
}


//각 선분을 따로따로 배열에 표기해줘야 했다. 이 점을 놓치고 
//각 선분이 존재하는지 아닌지 여부를 하나의 배열안에 count해서 2이상 count된 부분이 연속으로
//존재하는 곳을 체크하다가 예상하지도 못한 예외 케이스가 발견되었다. 

//Ex)
//[[0, 2], [-3, -1], [-2, 1]]의 경우
//-3~2까지 총 6칸이 생기고 0번지를 -3이라고 생각하면
//1 2 2 2 2 1
//2가 연이어져 있어서 3이지지만, 실제로 각 선분을 나누어서 표시해보면

//[0,2]   0 0 0 1 1 1
//[-3,-1] 1 1 1 0 0 0
//[-2, 1] 0 1 1 1 1 0

//로, 사실 0~1사이는 [-2,1] 선분만 지나가는데도 불구하고 연결되어있는 것처럼 계산된다.

//이를 해결하기 위해선 위와 같이 선분 각각의 정보를 나누어서 저장하면서
//동시에 count에 의미가 없는 선분의 꼭짓점 정보 한개를 무시하여 저장해준다.
//즉, endpoint나 startpoint둘 중 하나를 부등식 범위에서 뺴준다는 것(<= 에서 <로)
//이러면 다음과 같이 바뀐다.

//[0,2]   0 0 0 1 1 0
//[-3,-1] 1 1 0 0 0 0
//[-2, 1] 0 1 1 1 0 0
// sum    1 2 1 2 1 0
// 이렇게 합산 2이상인 부분만 추려내면 총 겹치는 길이가 된다.

//굳이 꼭짓점 정보를 전부 살려가면서 구현한다면

                        //선분이름
//[0,2]   0 0 0 1 1 1  ->   a
//[-3,-1] 1 1 1 0 0 0  ->   b
//[-2, 1] 0 1 1 1 1 0  ->   c

//위와 같이 0~1사이는 선분 a와 c하고 겹치다가 b하고 c와 겹치는 부분으로 넘어간다는 특징이 있는데
//이렇듯 현재 겹쳐지고 있는 선분의 정보를 따로 저장해둬서
//갑자기 다음 Index에서 바뀌는 경우를 예외처리하는 방법도 있다.


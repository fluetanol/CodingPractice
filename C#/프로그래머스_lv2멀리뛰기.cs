//https://school.programmers.co.kr/learn/courses/30/lessons/12914#
//프로그래머스_lv2멀리뛰기
//2024.03.27
//40분

using System;
using System.Collections.Generic;
public class 프로그래머스_lv2멀리뛰기 {
    private Dictionary<int,long> d = new Dictionary<int,long>();
    
    public long jump(int n, int m){
        if(m > n) return 0;
        if(m == n) return 1;
        if(d.ContainsKey(m)) return d[m];
        long k = jump(n, m+1) + jump(n, m+2);
        if(k>=1234567) k -= 1234567;
        d[m] = k;
        return k;
    }
    
    public long solution(int n) {
        long answer = 0;
        answer = jump(n, 0);
        return answer;
    }
}

//아주 지랄난 문제
//DFS/BFS + DP + 나머지 성질 세 개를 활용해야하는 문제다.
//그래도 재밌는 문제.

//첫번째 난관
//우선 해당 턴에 1칸을 움직일지, 2칸을 움직일지
//선택지가 나뉘게 되는데 이를 DFS/BFS로 구현한다.
//쉽게 하려면 재귀함수 이용하면 됨

//두번째 난관
//그런데 그냥 재귀를 돌리면 DEPTH마다 2^log(n)개 만큼의
//지수적 재귀함수 호출을 하게 된다. 즉, 시간복잡도에서 터져버린다는 것.
//따라서 반복 사용될 데이터를 저장해두는 방식을 써야한다.
//가장 좋은 방법은 해당 데이터를 거쳤을때, 몇 개의 정답이 나올지 보장이 되는지를
//적어두면 된다.
//예를 들어 n= 4라고 해보자

//        0
//      1   2
//    2   3   4
//  3   4     
//4

//위 코드대로라면 재귀함수에 의해 0->1->2->3->4까지 가서야 첫 리턴이 될 것인데

//이때 3은 1을 더했을때 1을 리턴받고, 2를 더하면 초과되므로 0을 리턴받는다.
//이 둘을 합하면 3이라는 숫자를 거치면 반드시 1개의 가능 루트를 얻는 다는 걸 알 수 있다.

//이번에 2를 리턴받으면 3이라는 숫자에서 1, 2를 더한 4에서 1을 또 리턴받는다.
//즉, 2를 거치면 2개의 가능한 선택지가 있다는 걸 보장받을 수 있다.

//또 1을 거친다면 앞선 2라는 값에서 2를 리턴 받는 다는 걸 알아냈고,
//2를 더하면 3을 만나게 되는데, 아까 3을 만나면 반드시 1개의 가능 루트가 있음을 알았기 때문에
//1을 리턴받는 바, 1+2 = 3가지의 경우의 수가 존재하는 숫자임을 알 수 있다.

//이런 식으로, 현재 숫자 m에 대한 함수 재귀 결과가 곧 그 숫자가 등장 시
//가능한 루트의 경우의 수라는 게 되므로, 이는 재활용 할 시 좋을 것이다.
//따라서
/*
        long k = jump(n, m+1) + jump(n, m+2);
        d[m] = k;
*/
//와 같이 딕셔너리에 어떤 숫자에 대한 가능 루트수를 저장해주고
/*
        if(d.ContainsKey(m)) return d[m];
*/
//이미 딕셔너리에 해당 숫자가 있으면 딕셔너리에 이미 저장된 그 숫자에 대한 가능 루트수를 반환시켜주면 된다.


//세번째 난관
//문제는 이렇게 하면 시간 복잡도는 개선될 지언정, 숫자값은 엄청 크다는 사실이 변함 없다는 것인데,
//실제로 테스트 해보면 long타입으로도 n=100도 감당을 못함을 알 수 있다.
//애초에 숫자가 짤려나가거나 아예 오버플로우 일어남.
//그럼 재귀 도중에 오버플로우가 안나도록 짜르라는 얘기인데, 어케 하라는 말인가??

//다음 문제를 생각해보자
//10을 2로 나눈 나머지를 구해보라 
//쉽게 생각하면 10%2를 해도 그만이긴 한데,
//바보같이 1씩 카운트 해가며 나머지를 구한다고 생각해보자

//1%2 = 1
//2%2 = 0
//3%2 = 1
//4%2 = 0
..
//9%2 = 1
//10%2 = 0

//어라, 생각해보니 나머지는 주기를 이루면서 반복된다.
//10%2든 2%2든 4%2든 똑같은 0이다.
//즉, 만약 우리가
/*
int k=0;
for(int i=1; i<=10; i++){
    k++;
   if(k>=2) k-=2;
}
Console.Write("10%2나머지 "+ k);
이렇게 나머지 주기가 돌 때마다 카운트 값을 0으로 돌려보내도
나머지 결과는 동일하다는 것.
*/
//따라서 
/*        
long k = jump(n, m+1) + jump(n, m+2);
if(k>=1234567) k -= 1234567;
d[m] = k;
*/
//와 같이 이 문제의 나머지의 주기인 1234567을 넘어가면
//그만큼 뺴주면서 숫자가 과하게 커지지 않게 함과 동시에
//나머지 정보를 계속 살려두면 된다.
//저 정보 그대로 딕셔너리에 넣어도 됨.